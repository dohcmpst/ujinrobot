###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         06/Oct/2023  13:39:20
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =  R:\STM32F205RC-Booter\Source\ARMCM3_STM32F2\flash.c
#    Command line      =
#        -f
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir\flash.o.rsp
#        (R:\STM32F205RC-Booter\Source\ARMCM3_STM32F2\flash.c -D USE_HAL_DRIVER
#        -D USE_FULL_LL_DRIVER -D STM32F205xx -lcN
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir
#        -o
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.4\arm\inc\c\DLib_Config_Normal.h" -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Device\ST\STM32F2xx\Include\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Include\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\fatfs\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\Legacy\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ARMCM3_STM32F2\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\third_party\fatfs\src\
#        -Ol) --dependencies=n
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir\flash.o.iar_deps
#    Locale            =  C
#    List file         =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir\flash.lst
#    Object file       =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\ARMCM3_STM32F2_12879159777159738471.dir\flash.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

R:\STM32F205RC-Booter\Source\ARMCM3_STM32F2\flash.c
      1          /************************************************************************************//**
      2          * \file         Source/ARMCM3_STM32F2/flash.c
      3          * \brief        Bootloader flash driver source file.
      4          * \ingroup      Target_ARMCM3_STM32F2
      5          * \internal
      6          *----------------------------------------------------------------------------------------
      7          *                          C O P Y R I G H T
      8          *----------------------------------------------------------------------------------------
      9          *   Copyright (c) 2016  by Feaser    http://www.feaser.com    All rights reserved
     10          *
     11          *----------------------------------------------------------------------------------------
     12          *                            L I C E N S E
     13          *----------------------------------------------------------------------------------------
     14          * This file is part of OpenBLT. OpenBLT is free software: you can redistribute it and/or
     15          * modify it under the terms of the GNU General Public License as published by the Free
     16          * Software Foundation, either version 3 of the License, or (at your option) any later
     17          * version.
     18          *
     19          * OpenBLT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
     20          * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     21          * PURPOSE. See the GNU General Public License for more details.
     22          *
     23          * You have received a copy of the GNU General Public License along with OpenBLT. It
     24          * should be located in ".\Doc\license.html". If not, contact Feaser to obtain a copy.
     25          *
     26          * \endinternal
     27          ****************************************************************************************/
     28          
     29          /****************************************************************************************
     30          * Include files
     31          ****************************************************************************************/
     32          #include "boot.h"                                /* bootloader generic header          */
     33          #include "stm32f2xx.h"                           /* STM32 CPU and HAL header           */
     34          
     35          
     36          /****************************************************************************************
     37          * Macro definitions
     38          ****************************************************************************************/
     39          /** \brief Value for an invalid flash sector. */
     40          #define FLASH_INVALID_SECTOR            (0xff)
     41          /** \brief Value for an invalid flash address. */
     42          #define FLASH_INVALID_ADDRESS           (0xffffffff)
     43          /** \brief Standard size of a flash block for writing. */
     44          #define FLASH_WRITE_BLOCK_SIZE          (512)
     45          /** \brief Total numbers of sectors in array flashLayout[]. */
     46          #define FLASH_TOTAL_SECTORS             (sizeof(flashLayout)/sizeof(flashLayout[0]))
     47          /** \brief End address of the bootloader programmable flash. */
     48          #define FLASH_END_ADDRESS               (flashLayout[FLASH_TOTAL_SECTORS-1].sector_start + \
     49                                                   flashLayout[FLASH_TOTAL_SECTORS-1].sector_size - 1)
     50          /** \brief Offset into the user program's vector table where the checksum is located. 
     51           *         For this target it is set to the end of the vector table. Note that the 
     52           *         value can be overriden in blt_conf.h, because the size of the vector table
     53           *         could vary. When changing this value, don't forget to update the location
     54           *         of the checksum in the user program accordingly. Otherwise the checksum
     55           *         verification will always fail.
     56           */
     57          #ifndef BOOT_FLASH_VECTOR_TABLE_CS_OFFSET
     58          #define BOOT_FLASH_VECTOR_TABLE_CS_OFFSET    (0x184)
     59          #endif
     60          
     61          
     62          /****************************************************************************************
     63          * Plausibility checks
     64          ****************************************************************************************/
     65          #if (BOOT_FLASH_VECTOR_TABLE_CS_OFFSET >= FLASH_WRITE_BLOCK_SIZE)
     66          #error "BOOT_FLASH_VECTOR_TABLE_CS_OFFSET is set too high. It must be located in the first writable block."
     67          #endif
     68          
     69          #ifndef BOOT_FLASH_CUSTOM_LAYOUT_ENABLE
     70          #define BOOT_FLASH_CUSTOM_LAYOUT_ENABLE (0u)
     71          #endif
     72          
     73          
     74          /****************************************************************************************
     75          * Type definitions
     76          ****************************************************************************************/
     77          /** \brief Flash sector descriptor type. */
     78          typedef struct
     79          {
     80            blt_addr   sector_start;                       /**< sector start address             */
     81            blt_int32u sector_size;                        /**< sector size in bytes             */
     82            blt_int8u  sector_num;                         /**< sector number                    */
     83          } tFlashSector;
     84          
     85          /** \brief    Structure type for grouping flash block information.
     86           *  \details  Programming is done per block of max FLASH_WRITE_BLOCK_SIZE. for this a
     87           *            flash block manager is implemented in this driver. this flash block manager
     88           *            depends on this flash block info structure. It holds the base address of
     89           *            the flash block and the data that should be programmed into the flash
     90           *            block. The .base_addr must be a multiple of FLASH_WRITE_BLOCK_SIZE.
     91           */
     92          typedef struct
     93          {
     94            blt_addr  base_addr;
     95            blt_int8u data[FLASH_WRITE_BLOCK_SIZE];
     96          } tFlashBlockInfo;
     97          
     98          
     99          /****************************************************************************************
    100          * Hook functions
    101          ****************************************************************************************/
    102          #if (BOOT_FLASH_CRYPTO_HOOKS_ENABLE > 0)
    103          extern blt_bool FlashCryptoDecryptDataHook(blt_addr address, blt_int8u * data, 
    104                                                     blt_int32u size);
    105          #endif
    106          
    107          
    108          /****************************************************************************************
    109          * Function prototypes
    110          ****************************************************************************************/
    111          static blt_bool  FlashInitBlock(tFlashBlockInfo *block, blt_addr address);
    112          static tFlashBlockInfo *FlashSwitchBlock(tFlashBlockInfo *block, blt_addr base_addr);
    113          static blt_bool  FlashAddToBlock(tFlashBlockInfo *block, blt_addr address,
    114                                           blt_int8u *data, blt_int32u len);
    115          static blt_bool  FlashWriteBlock(tFlashBlockInfo *block);
    116          static blt_bool  FlashEraseSectors(blt_int8u first_sector, blt_int8u last_sector);
    117          static blt_bool  FlashEmptyCheckSector(blt_int8u sector_num);
    118          static blt_int8u FlashGetSector(blt_addr address);
    119          
    120          
    121          /****************************************************************************************
    122          * Local constant declarations
    123          ****************************************************************************************/
    124          /** \brief   If desired, it is possible to set BOOT_FLASH_CUSTOM_LAYOUT_ENABLE to > 0
    125           *           in blt_conf.h and then implement your own version of the flashLayout[] table
    126           *           in a source-file with the name flash_layout.c. This way you customize the
    127           *           flash memory size reserved for the bootloader, without having to modify
    128           *           the flashLayout[] table in this file directly. This file will then include
    129           *           flash_layout.c so there is no need to compile it additionally with your
    130           *           project.
    131           */
    132          #if (BOOT_FLASH_CUSTOM_LAYOUT_ENABLE == 0)
    133          /** \brief   Array wit the layout of the flash memory.
    134           *  \details Also controls what part of the flash memory is reserved for the bootloader.
    135           *           If the bootloader size changes, the reserved sectors for the bootloader
    136           *           might need adjustment to make sure the bootloader doesn't get overwritten.
    137           */
    138          static const tFlashSector flashLayout[] =
    139          {
    140            /* space is reserved for a bootloader configuration with all supported communication
    141             * interfaces enabled. when for example only UART is needed, then the space required
    142             * for the bootloader can be made a lot smaller here.
    143             */
    144            /* { 0x08000000, 0x04000,  0},           flash sector  0 - reserved for bootloader   */
    145            /* { 0x08004000, 0x04000,  1},           flash sector  1 - reserved for bootloader   */
    146            { 0x08008000, 0x04000,  2},           /* flash sector  2 -  16kb                     */
    147            { 0x0800c000, 0x04000,  3},           /* flash sector  3 -  16kb                     */
    148            { 0x08010000, 0x10000,  4},           /* flash sector  4 -  64kb                     */
    149          #if (BOOT_NVM_SIZE_KB > 128)
    150            { 0x08020000, 0x20000,  5},           /* flash sector  5 - 128kb                     */
    151          #endif
    152          #if (BOOT_NVM_SIZE_KB > 256)
    153            { 0x08040000, 0x20000,  6},           /* flash sector  6 - 128kb                     */
    154            { 0x08060000, 0x20000,  7},           /* flash sector  7 - 128kb                     */
    155          #endif
    156          #if (BOOT_NVM_SIZE_KB > 512)
    157            { 0x08080000, 0x20000,  8},           /* flash sector  8 - 128kb                     */
    158            { 0x080A0000, 0x20000,  9},           /* flash sector  9 - 128kb                     */
    159            { 0x080C0000, 0x20000, 10},           /* flash sector 10 - 128kb                     */
    160            { 0x080E0000, 0x20000, 11},           /* flash sector 11 - 128kb                     */
    161          #endif
    162          #if (BOOT_NVM_SIZE_KB > 1024)
    163          #error "BOOT_NVM_SIZE_KB > 1024 is currently not supported."
    164          #endif
    165          };
    166          #else
    167          #include "flash_layout.c"
    168          #endif /* BOOT_FLASH_CUSTOM_LAYOUT_ENABLE == 0 */
    169          
    170          
    171          /****************************************************************************************
    172          * Local data declarations
    173          ****************************************************************************************/
    174          /** \brief   Local variable with information about the flash block that is currently
    175           *           being operated on.
    176           *  \details The smallest amount of flash that can be programmed is
    177           *           FLASH_WRITE_BLOCK_SIZE. A flash block manager is implemented in this driver
    178           *           and stores info in this variable. Whenever new data should be flashed, it
    179           *           is first added to a RAM buffer, which is part of this variable. Whenever
    180           *           the RAM buffer, which has the size of a flash block, is full or  data needs
    181           *           to be written to a different block, the contents of the RAM buffer are
    182           *           programmed to flash. The flash block manager requires some software
    183           *           overhead, yet results is faster flash programming because data is first
    184           *           harvested, ideally until there is enough to program an entire flash block,
    185           *           before the flash device is actually operated on.
    186           */
    187          static tFlashBlockInfo blockInfo;
    188          
    189          /** \brief   Local variable with information about the flash boot block.
    190           *  \details The first block of the user program holds the vector table, which on the
    191           *           STM32 is also the where the checksum is written to. Is it likely that
    192           *           the vector table is first flashed and then, at the end of the programming
    193           *           sequence, the checksum. This means that this flash block need to be written
    194           *           to twice. Normally this is not a problem with flash memory, as long as you
    195           *           write the same values to those bytes that are not supposed to be changed
    196           *           and the locations where you do write to are still in the erased 0xFF state.
    197           *           Unfortunately, writing twice to flash this way, does not work reliably on
    198           *           all micros. This is why we need to have an extra block, the bootblock,
    199           *           placed under the management of the block manager. This way is it possible
    200           *           to implement functionality so that the bootblock is only written to once
    201           *           at the end of the programming sequence.
    202           */
    203          static tFlashBlockInfo bootBlockInfo;
    204          
    205          
    206          /************************************************************************************//**
    207          ** \brief     Initializes the flash driver.
    208          ** \return    none.
    209          **
    210          ****************************************************************************************/
    211          void FlashInit(void)
    212          {
    213            /* init the flash block info structs by setting the address to an invalid address */
    214            blockInfo.base_addr = FLASH_INVALID_ADDRESS;
    215            bootBlockInfo.base_addr = FLASH_INVALID_ADDRESS;
    216          } /*** end of FlashInit ***/
    217          
    218          
    219          /************************************************************************************//**
    220          ** \brief     Reinitializes the flash driver.
    221          ** \return    none.
    222          **
    223          ****************************************************************************************/
    224          void FlashReinit(void)
    225          {
    226            /* init the flash block info structs by setting the address to an invalid address */
    227            blockInfo.base_addr = FLASH_INVALID_ADDRESS;
    228            bootBlockInfo.base_addr = FLASH_INVALID_ADDRESS;
    229          } /*** end of FlashReinit ***/
    230          
    231          
    232          /************************************************************************************//**
    233          ** \brief     Writes the data to flash through a flash block manager. Note that this
    234          **            function also checks that no data is programmed outside the flash
    235          **            memory region, so the bootloader can never be overwritten.
    236          ** \param     addr Start address.
    237          ** \param     len  Length in bytes.
    238          ** \param     data Pointer to the data buffer.
    239          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    240          **
    241          ****************************************************************************************/
    242          blt_bool FlashWrite(blt_addr addr, blt_int32u len, blt_int8u *data)
    243          {
    244            blt_addr base_addr;
    245          
    246            /* validate the len parameter */
    247            if ((len - 1) > (FLASH_END_ADDRESS - addr))
    248            {
    249              return BLT_FALSE;
    250            }
    251            
    252            /* make sure the addresses are within the flash device */
    253            if ((FlashGetSector(addr) == FLASH_INVALID_SECTOR) || \
    254                (FlashGetSector(addr+len-1) == FLASH_INVALID_SECTOR))
    255            {
    256              return BLT_FALSE;
    257            }
    258          
    259            /* if this is the bootblock, then let the boot block manager handle it */
    260            base_addr = (addr/FLASH_WRITE_BLOCK_SIZE)*FLASH_WRITE_BLOCK_SIZE;
    261            if (base_addr == flashLayout[0].sector_start)
    262            {
    263              /* let the boot block manager handle it */
    264              return FlashAddToBlock(&bootBlockInfo, addr, data, len);
    265            }
    266            /* let the block manager handle it */
    267            return FlashAddToBlock(&blockInfo, addr, data, len);
    268          } /*** end of FlashWrite ***/
    269          
    270          
    271          /************************************************************************************//**
    272          ** \brief     Erases the flash memory. Note that this function also checks that no
    273          **            data is erased outside the flash memory region, so the bootloader can
    274          **            never be erased.
    275          ** \param     addr Start address.
    276          ** \param     len  Length in bytes.
    277          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    278          **
    279          ****************************************************************************************/
    280          blt_bool FlashErase(blt_addr addr, blt_int32u len)
    281          {
    282            blt_int8u first_sector;
    283            blt_int8u last_sector;
    284          
    285            /* validate the len parameter */
    286            if ((len - 1) > (FLASH_END_ADDRESS - addr))
    287            {
    288              return BLT_FALSE;
    289            }
    290            
    291            /* obtain the first and last sector number */
    292            first_sector = FlashGetSector(addr);
    293            last_sector  = FlashGetSector(addr+len-1);
    294            /* check them */
    295            if ((first_sector == FLASH_INVALID_SECTOR) || (last_sector == FLASH_INVALID_SECTOR))
    296            {
    297              return BLT_FALSE;
    298            }
    299            /* erase the sectors */
    300            return FlashEraseSectors(first_sector, last_sector);
    301          } /*** end of FlashErase ***/
    302          
    303          
    304          /************************************************************************************//**
    305          ** \brief     Writes a checksum of the user program to non-volatile memory. This is
    306          **            performed once the entire user program has been programmed. Through
    307          **            the checksum, the bootloader can check if the programming session
    308          **            was completed, which indicates that a valid user programming is
    309          **            present and can be started.
    310          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    311          **
    312          ****************************************************************************************/
    313          blt_bool FlashWriteChecksum(void)
    314          {
    315            blt_int32u signature_checksum = 0;
    316          
    317            /* for the STM32 target we defined the checksum as the Two's complement value of the
    318             * sum of the first 7 exception addresses.
    319             *
    320             * Layout of the vector table:
    321             *    0x08000000 Initial stack pointer
    322             *    0x08000004 Reset Handler
    323             *    0x08000008 NMI Handler
    324             *    0x0800000C Hard Fault Handler
    325             *    0x08000010 MPU Fault Handler
    326             *    0x08000014 Bus Fault Handler
    327             *    0x08000018 Usage Fault Handler
    328             *
    329             *    signature_checksum = Two's complement of (SUM(exception address values))
    330             *
    331             *    the bootloader writes this 32-bit checksum value right after the vector table
    332             *    of the user program. note that this means one extra dummy entry must be added
    333             *    at the end of the user program's vector table to reserve storage space for the
    334             *    checksum.
    335             */
    336          
    337            /* first check that the bootblock contains valid data. if not, this means the
    338             * bootblock is not part of the reprogramming this time and therefore no
    339             * new checksum needs to be written
    340             */
    341            if (bootBlockInfo.base_addr == FLASH_INVALID_ADDRESS)
    342            {
    343              return BLT_TRUE;
    344            }
    345          
    346          #if (BOOT_FLASH_CRYPTO_HOOKS_ENABLE > 0)
    347            /* perform decryption of the bootblock, before calculating the checksum and writing it
    348             * to flash memory.
    349             */
    350            if (FlashCryptoDecryptDataHook(bootBlockInfo.base_addr, bootBlockInfo.data, 
    351                                           FLASH_WRITE_BLOCK_SIZE) == BLT_FALSE)
    352            {
    353              return BLT_FALSE;
    354            }
    355          #endif
    356          
    357            /* compute the checksum. note that the user program's vectors are not yet written
    358             * to flash but are present in the bootblock data structure at this point.
    359             */
    360            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x00]));
    361            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x04]));
    362            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x08]));
    363            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x0C]));
    364            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x10]));
    365            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x14]));
    366            signature_checksum += *((blt_int32u *)(&bootBlockInfo.data[0+0x18]));
    367            signature_checksum  = ~signature_checksum; /* one's complement */
    368            signature_checksum += 1; /* two's complement */
    369          
    370            /* write the checksum */
    371            return FlashWrite(flashLayout[0].sector_start+BOOT_FLASH_VECTOR_TABLE_CS_OFFSET,
    372                              sizeof(blt_addr), (blt_int8u *)&signature_checksum);
    373          } /*** end of FlashWriteChecksum ***/
    374          
    375          
    376          /************************************************************************************//**
    377          ** \brief     Verifies the checksum, which indicates that a valid user program is
    378          **            present and can be started.
    379          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    380          **
    381          ****************************************************************************************/
    382          blt_bool FlashVerifyChecksum(void)
    383          {
    384            blt_int32u signature_checksum = 0;
    385          
    386            /* verify the checksum based on how it was written by CpuWriteChecksum() */
    387            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start));
    388            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x04));
    389            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x08));
    390            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x0C));
    391            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x10));
    392            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x14));
    393            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+0x18));
    394            signature_checksum += *((blt_int32u *)(flashLayout[0].sector_start+BOOT_FLASH_VECTOR_TABLE_CS_OFFSET));
    395            /* sum should add up to an unsigned 32-bit value of 0 */
    396            
    397            Debug_Message("\nFlashVerifyChecksum() -> ");
    398            if (signature_checksum == 0)
    399            {
    400              /* checksum okay */
    401              Debug_Message("TRUE\n");
    402              return BLT_TRUE;
    403            }
    404            /* checksum incorrect */
    405            Debug_Message("FALSE\n");
    406            return BLT_FALSE;
    407          } /*** end of FlashVerifyChecksum ***/
    408          
    409          
    410          /************************************************************************************//**
    411          ** \brief     Finalizes the flash driver operations. There could still be data in
    412          **            the currently active block that needs to be flashed.
    413          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    414          **
    415          ****************************************************************************************/
    416          blt_bool FlashDone(void)
    417          {
    418            /* check if there is still data waiting to be programmed in the boot block */
    419            if (bootBlockInfo.base_addr != FLASH_INVALID_ADDRESS)
    420            {
    421              if (FlashWriteBlock(&bootBlockInfo) == BLT_FALSE)
    422              {
    423                return BLT_FALSE;
    424              }
    425            }
    426          
    427            /* check if there is still data waiting to be programmed */
    428            if (blockInfo.base_addr != FLASH_INVALID_ADDRESS)
    429            {
    430              if (FlashWriteBlock(&blockInfo) == BLT_FALSE)
    431              {
    432                return BLT_FALSE;
    433              }
    434            }
    435            /* still here so all is okay */
    436            return BLT_TRUE;
    437          } /*** end of FlashDone ***/
    438          
    439          
    440          /************************************************************************************//**
    441          ** \brief     Obtains the base address of the flash memory available to the user program.
    442          **            This is basically the first address in the flashLayout table.
    443          ** \return    Base address.
    444          **
    445          ****************************************************************************************/
    446          blt_addr FlashGetUserProgBaseAddress(void)
    447          {
    448            return flashLayout[0].sector_start;
    449          } /*** end of FlashGetUserProgBaseAddress ***/
    450          
    451          
    452          /************************************************************************************//**
    453          ** \brief     Copies data currently in flash to the block->data and sets the
    454          **            base address.
    455          ** \param     block   Pointer to flash block info structure to operate on.
    456          ** \param     address Base address of the block data.
    457          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    458          **
    459          ****************************************************************************************/
    460          static blt_bool FlashInitBlock(tFlashBlockInfo *block, blt_addr address)
    461          {
    462            /* check address alignment */
    463            if ((address % FLASH_WRITE_BLOCK_SIZE) != 0)
    464            {
    465              return BLT_FALSE;
    466            }
    467            /* make sure that we are initializing a new block and not the same one */
    468            if (block->base_addr == address)
    469            {
    470              /* block already initialized, so nothing to do */
    471              return BLT_TRUE;
    472            }
    473            /* set the base address and copies the current data from flash */
    474            block->base_addr = address;
    475            CpuMemCopy((blt_addr)block->data, address, FLASH_WRITE_BLOCK_SIZE);
    476            return BLT_TRUE;
    477          } /*** end of FlashInitBlock ***/
    478          
    479          
    480          /************************************************************************************//**
    481          ** \brief     Switches blocks by programming the current one and initializing the
    482          **            next.
    483          ** \param     block   Pointer to flash block info structure to operate on.
    484          ** \param     base_addr Base address of the next block.
    485          ** \return    The pointer of the block info struct that is no being used, or a NULL
    486          **            pointer in case of error.
    487          **
    488          ****************************************************************************************/
    489          static tFlashBlockInfo *FlashSwitchBlock(tFlashBlockInfo *block, blt_addr base_addr)
    490          {
    491            /* check if a switch needs to be made away from the boot block. in this case the boot
    492             * block shouldn't be written yet, because this is done at the end of the programming
    493             * session by FlashDone(), this is right after the checksum was written.
    494             */
    495            if (block == &bootBlockInfo)
    496            {
    497              /* switch from the boot block to the generic block info structure */
    498              block = &blockInfo;
    499            }
    500            /* check if a switch back into the bootblock is needed. in this case the generic block
    501             * doesn't need to be written here yet.
    502             */
    503            else if (base_addr == flashLayout[0].sector_start)
    504            {
    505              /* switch from the generic block to the boot block info structure */
    506              block = &bootBlockInfo;
    507              base_addr = flashLayout[0].sector_start;
    508            }
    509            else
    510            {
    511              /* need to switch to a new block, so program the current one and init the next */
    512              if (FlashWriteBlock(block) == BLT_FALSE)
    513              {
    514                return BLT_NULL;
    515              }
    516            }
    517          
    518            /* initialize tne new block when necessary */
    519            if (FlashInitBlock(block, base_addr) == BLT_FALSE)
    520            {
    521              return BLT_NULL;
    522            }
    523          
    524            /* still here to all is okay  */
    525            return block;
    526          } /*** end of FlashSwitchBlock ***/
    527          
    528          
    529          /************************************************************************************//**
    530          ** \brief     Programming is done per block. This function adds data to the block
    531          **            that is currently collecting data to be written to flash. If the
    532          **            address is outside of the current block, the current block is written
    533          **            to flash an a new block is initialized.
    534          ** \param     block   Pointer to flash block info structure to operate on.
    535          ** \param     address Flash destination address.
    536          ** \param     data    Pointer to the byte array with data.
    537          ** \param     len     Number of bytes to add to the block.
    538          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    539          **
    540          ****************************************************************************************/
    541          static blt_bool FlashAddToBlock(tFlashBlockInfo *block, blt_addr address,
    542                                          blt_int8u *data, blt_int32u len)
    543          {
    544            blt_addr   current_base_addr;
    545            blt_int8u  *dst;
    546            blt_int8u  *src;
    547          
    548            /* determine the current base address */
    549            current_base_addr = (address/FLASH_WRITE_BLOCK_SIZE)*FLASH_WRITE_BLOCK_SIZE;
    550          
    551            /* make sure the blockInfo is not uninitialized */
    552            if (block->base_addr == FLASH_INVALID_ADDRESS)
    553            {
    554              /* initialize the blockInfo struct for the current block */
    555              if (FlashInitBlock(block, current_base_addr) == BLT_FALSE)
    556              {
    557                return BLT_FALSE;
    558              }
    559            }
    560          
    561            /* check if the new data fits in the current block */
    562            if (block->base_addr != current_base_addr)
    563            {
    564              /* need to switch to a new block, so program the current one and init the next */
    565              block = FlashSwitchBlock(block, current_base_addr);
    566              if (block == BLT_NULL)
    567              {
    568                return BLT_FALSE;
    569              }
    570            }
    571          
    572            /* add the data to the current block, but check for block overflow */
    573            dst = &(block->data[address - block->base_addr]);
    574            src = data;
    575            do
    576            {
    577              /* keep the watchdog happy */
    578              CopService();
    579              /* buffer overflow? */
    580              if ((blt_addr)(dst-&(block->data[0])) >= FLASH_WRITE_BLOCK_SIZE)
    581              {
    582                /* need to switch to a new block, so program the current one and init the next */
    583                block = FlashSwitchBlock(block, current_base_addr+FLASH_WRITE_BLOCK_SIZE);
    584                if (block == BLT_NULL)
    585                {
    586                  return BLT_FALSE;
    587                }
    588                /* reset destination pointer */
    589                dst = &(block->data[0]);
    590              }
    591              /* write the data to the buffer */
    592              *dst = *src;
    593              /* update pointers */
    594              dst++;
    595              src++;
    596              /* decrement byte counter */
    597              len--;
    598            }
    599            while (len > 0);
    600            /* still here so all is good */
    601            return BLT_TRUE;
    602          } /*** end of FlashAddToBlock ***/
    603          
    604          
    605          /************************************************************************************//**
    606          ** \brief     Programs FLASH_WRITE_BLOCK_SIZE bytes to flash from the block->data
    607          **            array.
    608          ** \param     block   Pointer to flash block info structure to operate on.
    609          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    610          **
    611          ****************************************************************************************/
    612          static blt_bool FlashWriteBlock(tFlashBlockInfo *block)
    613          {
    614            blt_addr   prog_addr;
    615            blt_int32u prog_data;
    616            blt_int32u word_cnt;
    617            blt_bool   result = BLT_TRUE;
    618          
    619          #if (BOOT_FLASH_CRYPTO_HOOKS_ENABLE > 0)
    620            #if (BOOT_NVM_CHECKSUM_HOOKS_ENABLE == 0)
    621            /* note that the bootblock is already decrypted in FlashWriteChecksum(), if the
    622             * internal checksum mechanism is used. Therefore don't decrypt it again.
    623             */
    624            if (block != &bootBlockInfo)
    625            #endif
    626            {
    627              /* perform decryption of the program data before writing it to flash memory. */
    628              if (FlashCryptoDecryptDataHook(block->base_addr, block->data, 
    629                                             FLASH_WRITE_BLOCK_SIZE) == BLT_FALSE)
    630              {
    631                return BLT_FALSE;
    632              }
    633            }
    634          #endif
    635          
    636            /* unlock the flash peripheral to enable the flash control register access. */
    637            HAL_FLASH_Unlock();
    638          
    639            /* program all words in the block one by one */
    640            for (word_cnt=0; word_cnt<(FLASH_WRITE_BLOCK_SIZE/sizeof(blt_int32u)); word_cnt++)
    641            {
    642              prog_addr = block->base_addr + (word_cnt * sizeof(blt_int32u));
    643              prog_data = *(volatile blt_int32u *)(&block->data[word_cnt * sizeof(blt_int32u)]);
    644              /* keep the watchdog happy */
    645              CopService();
    646              /* program the word */
    647              if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, prog_addr, prog_data) != HAL_OK)
    648              {
    649                result = BLT_FALSE;
    650                break;
    651              }
    652              /* verify that the written data is actually there */
    653              if (*(volatile blt_int32u *)prog_addr != prog_data)
    654              {
    655                result = BLT_FALSE;
    656                break;
    657              }
    658            }
    659          
    660            /* lock the flash peripheral to disable the flash control register access. */
    661            HAL_FLASH_Lock();
    662          
    663            /* Give the result back to the caller. */
    664            return result;
    665          } /*** end of FlashWriteBlock ***/
    666          
    667          
    668          /************************************************************************************//**
    669          ** \brief     Checks if the flash sector is already completely erased.
    670          ** \param     sector_num Sector number. Note that this is the sector_num element of the
    671          **            flashLayout array, not an index into the array.
    672          ** \return    BLT_TRUE if the flash sector is already erased, BLT_FALSE otherwise.
    673          **
    674          ****************************************************************************************/
    675          static blt_bool FlashEmptyCheckSector(blt_int8u sector_num)
    676          {
    677            blt_bool   result = BLT_FALSE;
    678            blt_addr   sectorAddr;
    679            blt_int32u sectorSize;
    680            blt_int8u  sectorIdx;
    681            blt_int32u wordCnt;
    682            blt_int32u volatile const * wordPtr;
    683            
    684            /* find the index of this sector into the flashLayout array */
    685            for (sectorIdx = 0; sectorIdx < FLASH_TOTAL_SECTORS; sectorIdx++)
    686            {
    687              /* is this the index that the sector number belongs to? */
    688              if (flashLayout[sectorIdx].sector_num == sector_num)
    689              {
    690                /* retrieve sector info */
    691                sectorAddr = flashLayout[sectorIdx].sector_start;
    692                sectorSize = flashLayout[sectorIdx].sector_size;
    693                
    694                /* sanity check. sector base address should be 32-bit aligned and the size
    695                 * should be a multiple of 32-bits.
    696                 */
    697                ASSERT_RT(((sectorAddr % sizeof(blt_int32u)) == 0) && 
    698                          ((sectorSize % sizeof(blt_int32u)) == 0));  
    699                
    700                /* update result to success for now */
    701                result = BLT_TRUE;
    702                /* initialize the pointer to the first word in the sector */
    703                wordPtr = (blt_int32u volatile const *)sectorAddr;
    704                /* read sector 32-bits at a time */
    705                for (wordCnt = 0; wordCnt < (sectorSize/sizeof(blt_int32u)); wordCnt++)
    706                {
    707                  /* service the watchdog every 256th loop iteration */
    708                  if ((wordCnt % 256) == 0)
    709                  {
    710                    CopService();
    711                  }
    712                  /* word not in the erased state? */
    713                  if (*wordPtr != 0xFFFFFFFFu)
    714                  {
    715                    /* sector not empty, update the result accordingly */
    716                    result = BLT_FALSE;
    717                    /* no point in continuing the sector empty check */
    718                    break;
    719                  }
    720                  /* set pointer to the next word in the sector */
    721                  wordPtr++;
    722                }
    723                /* sector index found and checked. no need to continue with another one.*/
    724                break;
    725              }
    726            }  
    727            /* give the result back to the caller. */
    728            return result;
    729          } /*** end of FlashEmptyCheckSector ***/
    730          
    731          
    732          /************************************************************************************//**
    733          ** \brief     Erases the flash sectors from first_sector up until last_sector.
    734          ** \param     first_sector First flash sector number.
    735          ** \param     last_sector  Last flash sector number.
    736          ** \return    BLT_TRUE if successful, BLT_FALSE otherwise.
    737          **
    738          ****************************************************************************************/
    739          static blt_bool FlashEraseSectors(blt_int8u first_sector, blt_int8u last_sector)
    740          {
    741            blt_bool result = BLT_TRUE;
    742            blt_int8u sectorIdx;
    743            FLASH_EraseInitTypeDef eraseInitStruct;
    744            blt_int32u eraseSectorError = 0;
    745          
    746            /* validate the sector numbers */
    747            if (first_sector > last_sector)
    748            {
    749              result = BLT_FALSE;
    750            }
    751            if ((first_sector < flashLayout[0].sector_num) || \
    752                (last_sector > flashLayout[FLASH_TOTAL_SECTORS-1].sector_num))
    753            {
    754              result = BLT_FALSE;
    755            }
    756          
    757            /* only move forward with the erase operation if all is okay so far */
    758            if (result == BLT_TRUE)
    759            {
    760              /* intialize the sector erase info structure */
    761              eraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
    762              eraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;
    763              eraseInitStruct.NbSectors = 1;
    764          
    765              /* unlock the flash array */
    766              HAL_FLASH_Unlock();
    767          
    768              /* erase all sectors one by one */
    769              for (sectorIdx=first_sector; sectorIdx<= last_sector; sectorIdx++)
    770              {
    771                /* no need to erase the sector if it is already empty */
    772                if (FlashEmptyCheckSector(sectorIdx) == BLT_FALSE)
    773                {
    774                  /* keep the watchdog happy */
    775                  CopService();
    776                  /* set the sector to erase */
    777                  eraseInitStruct.Sector = sectorIdx;
    778                  /* submit the sector erase request */
    779                  if(HAL_FLASHEx_Erase(&eraseInitStruct, (uint32_t *)&eraseSectorError) != HAL_OK)
    780                  {
    781                    /* could not perform erase operation */
    782                    result = BLT_FALSE;
    783                    /* error detected so don't bother continuing with the loop */
    784                    break;
    785                  }
    786                }
    787              }
    788          
    789              /* lock the flash array again */
    790              HAL_FLASH_Lock();
    791            }
    792          
    793            /* give the result back to the caller */
    794            return result;
    795          } /*** end of FlashEraseSectors ***/
    796          
    797          
    798          /************************************************************************************//**
    799          ** \brief     Determines the flash sector the address is in.
    800          ** \param     address Address in the flash sector.
    801          ** \return    Flash sector number or FLASH_INVALID_SECTOR.
    802          **
    803          ****************************************************************************************/
    804          static blt_int8u FlashGetSector(blt_addr address)
    805          {
    806            blt_int8u result = FLASH_INVALID_SECTOR;
    807            blt_int8u sectorIdx;
    808          
    809            /* search through the sectors to find the right one */
    810            for (sectorIdx = 0; sectorIdx < FLASH_TOTAL_SECTORS; sectorIdx++)
    811            {
    812              /* keep the watchdog happy */
    813              CopService();
    814              /* is the address in this sector? */
    815              if ((address >= flashLayout[sectorIdx].sector_start) && \
    816                  (address < (flashLayout[sectorIdx].sector_start + \
    817                              flashLayout[sectorIdx].sector_size)))
    818              {
    819                /* found the sector we are looking for so store it */
    820                result = flashLayout[sectorIdx].sector_num;
    821                /* all done so no need to continue looping */
    822                break;
    823              }
    824            }
    825            /* give the result back to the caller */
    826            return result;
    827          } /*** end of FlashGetSector ***/
    828          
    829          
    830          /*********************************** end of flash.c ************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FlashAddToBlock
        24   -> CopService
        24   -> FlashInitBlock
        24   -> FlashSwitchBlock
       8   FlashDone
         8   -> FlashWriteBlock
      24   FlashEmptyCheckSector
        24   -> AssertFailure
        24   -> CopService
      16   FlashErase
        16   -> FlashEraseSectors
        16   -> FlashGetSector
      40   FlashEraseSectors
        40   -> CopService
        40   -> FlashEmptyCheckSector
        40   -> HAL_FLASHEx_Erase
        40   -> HAL_FLASH_Lock
        40   -> HAL_FLASH_Unlock
      16   FlashGetSector
        16   -> CopService
       0   FlashGetUserProgBaseAddress
       0   FlashInit
       8   FlashInitBlock
         8   -> CpuMemCopy
       0   FlashReinit
      16   FlashSwitchBlock
        16   -> FlashInitBlock
        16   -> FlashWriteBlock
       8   FlashVerifyChecksum
         8   -> Debug_Message
      24   FlashWrite
        24   -> FlashAddToBlock
        24   -> FlashGetSector
      24   FlashWriteBlock
        24   -> CopService
        24   -> HAL_FLASH_Lock
        24   -> HAL_FLASH_Program
        24   -> HAL_FLASH_Unlock
       8   FlashWriteChecksum
         8   -> FlashWrite


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
      28  ?_0
       8  ?_1
       8  ?_2
      52  ?_3
     146  FlashAddToBlock
      50  FlashDone
     120  FlashEmptyCheckSector
      82  FlashErase
     142  FlashEraseSectors
      80  FlashGetSector
       6  FlashGetUserProgBaseAddress
      18  FlashInit
      36  FlashInitBlock
      18  FlashReinit
      62  FlashSwitchBlock
     102  FlashVerifyChecksum
     100  FlashWrite
      82  FlashWriteBlock
     110  FlashWriteChecksum
     516  blockInfo
     516  bootBlockInfo
      48  flashLayout

 
 1'032 bytes in section .bss
   144 bytes in section .rodata
 1'182 bytes in section .text
 
 1'182 bytes of CODE  memory
   144 bytes of CONST memory
 1'032 bytes of DATA  memory

Errors: none
Warnings: none
