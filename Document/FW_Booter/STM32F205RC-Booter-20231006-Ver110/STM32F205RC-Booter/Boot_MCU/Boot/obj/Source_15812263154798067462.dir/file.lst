###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         06/Oct/2023  13:39:20
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =  R:\STM32F205RC-Booter\Source\file.c
#    Command line                 =
#        -f
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir\file.o.rsp
#        (R:\STM32F205RC-Booter\Source\file.c -D USE_HAL_DRIVER -D
#        USE_FULL_LL_DRIVER -D STM32F205xx -lcN
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir
#        -o
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.4\arm\inc\c\DLib_Config_Normal.h" -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Device\ST\STM32F2xx\Include\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Include\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\fatfs\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\Legacy\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ARMCM3_STM32F2\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\third_party\fatfs\src\
#        -Ol) --dependencies=n
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir\file.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir\file.lst
#    Object file                  =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\Source_15812263154798067462.dir\file.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

R:\STM32F205RC-Booter\Source\file.c
      1          /************************************************************************************//**
      2          * \file         Source/file.c
      3          * \brief        Bootloader file system interface source file.
      4          * \ingroup      Core
      5          * \internal
      6          *----------------------------------------------------------------------------------------
      7          *                          C O P Y R I G H T
      8          *----------------------------------------------------------------------------------------
      9          *   Copyright (c) 2013  by Feaser    http://www.feaser.com    All rights reserved
     10          *
     11          *----------------------------------------------------------------------------------------
     12          *                            L I C E N S E
     13          *----------------------------------------------------------------------------------------
     14          * This file is part of OpenBLT. OpenBLT is free software: you can redistribute it and/or
     15          * modify it under the terms of the GNU General Public License as published by the Free
     16          * Software Foundation, either version 3 of the License, or (at your option) any later
     17          * version.
     18          *
     19          * OpenBLT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
     20          * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     21          * PURPOSE. See the GNU General Public License for more details.
     22          *
     23          * You have received a copy of the GNU General Public License along with OpenBLT. It
     24          * should be located in ".\Doc\license.html". If not, contact Feaser to obtain a copy.
     25          *
     26          * \endinternal
     27          ****************************************************************************************/
     28          
     29          /****************************************************************************************
     30          * Include files
     31          ****************************************************************************************/
     32          #include "boot.h"                                     /* bootloader generic header     */
     33          #include <string.h>                                   /* for strcpy etc.               */
     34          #include <ctype.h>                                    /* for toupper() etc.            */
     35          
     36          
     37          #if (BOOT_FILE_SYS_ENABLE > 0)
     38          /****************************************************************************************
     39          * Type definitions
     40          ****************************************************************************************/
     41          /** \brief Enumeration for the different internal module states. */
     42          typedef enum
     43          {
     44            FIRMWARE_UPDATE_STATE_IDLE,                    /**< idle state                       */
     45            FIRMWARE_UPDATE_STATE_STARTING,                /**< starting state                   */
     46            FIRMWARE_UPDATE_STATE_ERASING,                 /**< erasing state                    */
     47            FIRMWARE_UPDATE_STATE_PROGRAMMING              /**< programming state                */
     48          } tFirmwareUpdateState;
     49          
     50          /** \brief Structure type with information for the memory erase opeartion. */
     51          typedef struct
     52          {
     53            blt_addr   start_address;                      /**< erase start address              */
     54            blt_int32u total_size;                         /**< total number of bytes to erase   */
     55          } tFileEraseInfo;
     56          
     57          /** \brief Structure type for grouping FATFS related objects used by this module. */
     58          typedef struct
     59          {
     60            FATFS fs;                                      /**< file system object for mouting   */
     61            FIL   file;                                    /**< file object for firmware file    */
     62          } tFatFsObjects;
     63          
     64          /****************************************************************************************
     65          * Function prototypes
     66          ****************************************************************************************/
     67          #if (BOOT_FILE_LOGGING_ENABLE > 0)
     68          static blt_char      FileLibByteNibbleToChar(blt_int8u nibble);
     69          static blt_char     *FileLibByteToHexString(blt_int8u byte_val, blt_char *destination);
     70          static blt_char     *FileLibLongToIntString(blt_int32u long_val, blt_char *destination);
     71          #endif
     72          static blt_int8u     FileLibHexStringToByte(const blt_char *hexstring);
     73          
     74          
     75          /****************************************************************************************
     76          * Hook functions
     77          ****************************************************************************************/
     78          extern blt_bool        FileIsFirmwareUpdateRequestedHook(void);
     79          extern const blt_char *FileGetFirmwareFilenameHook(void);
     80          extern void            FileFirmwareUpdateStartedHook(void);
     81          extern void            FileFirmwareUpdateCompletedHook(void);
     82          extern void            FileFirmwareUpdateErrorHook(blt_int8u error_code);
     83          extern void            FileFirmwareUpdateLogHook(blt_char *info_string);
     84          
     85          
     86          /****************************************************************************************
     87          * Local data declarations
     88          ****************************************************************************************/
     89          /** \brief Local variable that holds the internal module state. */
     90          static tFirmwareUpdateState firmwareUpdateState;
     91          /** \brief Local variable for the used FATFS objects in this module. */
     92          static tFatFsObjects        fatFsObjects;
     93          /** \brief Local variable for storing S-record line parsing results. */
     94          static tSrecLineParseObject lineParseObject;
     95          /** \brief Local variable for storing information regarding the memory erase operation.*/
     96          static tFileEraseInfo       eraseInfo;
     97          #if (BOOT_FILE_LOGGING_ENABLE > 0)
     98          /** \brief Local character buffer for storing the string with log information. */
     99          static blt_char             loggingStr[64];
    100          #endif
    101          
    102          
    103          /***********************************************************************************//**
    104          ** \brief     Initializes the file system interface module. The initial firmware
    105          **            update state is set to idle and the file system is mounted as
    106          **            logical disk 0.
    107          ** \return    none
    108          **
    109          ****************************************************************************************/
    110          void FileInit(void)
    111          {
    112            FRESULT fresult;
    113          
    114            /* set the initial state */
    115            firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    116            /* mount the file system, using logical disk 0 */
    117            fresult = f_mount(&fatFsObjects.fs, "0:", 0);
    118            /* mounting does not access the disk and should succeed unless misconfigured */
    119            ASSERT_RT(fresult == FR_OK);
    120          } /*** end of FileInit ***/
    121          
    122          
    123          /***********************************************************************************//**
    124          ** \brief     This function checks if a firmware update through the locally attached
    125          **            storage is in progress or not (idle).
    126          ** \return    BLT_TRUE when in idle state, BLT_FALSE otherwise.
    127          **
    128          ****************************************************************************************/
    129          blt_bool FileIsIdle(void)
    130          {
    131            if (firmwareUpdateState == FIRMWARE_UPDATE_STATE_IDLE)
    132            {
    133              return BLT_TRUE;
    134            }
    135            return BLT_FALSE;
    136          } /*** end of FileIsIdle ***/
    137          
    138          
    139          /***********************************************************************************//**
    140          ** \brief     This function checks if a firmware update through the locally attached
    141          **            storage is requested to be started and if so processes this request
    142          **            by transitioning from the IDLE to the STARTING state.
    143          ** \return    BLT_TRUE when a firmware update is requested, BLT_FALSE otherwise.
    144          **
    145          ****************************************************************************************/
    146          blt_bool FileHandleFirmwareUpdateRequest(void)
    147          {
    148          #if (BOOT_COM_ENABLE > 0)
    149            /* make sure that there is no connection with a remote host to prevent two firmware
    150             * updates happening at the same time
    151             */
    152            if (ComIsConnected() == BLT_TRUE)
    153            {
    154              return BLT_FALSE;
    155            }
    156          #endif
    157            /* a new firmware update request can only be handled if not already busy with one */
    158            if (firmwareUpdateState != FIRMWARE_UPDATE_STATE_IDLE)
    159            {
    160              return BLT_FALSE;
    161            }
    162            /* check if a firmware update is requested */
    163            if (FileIsFirmwareUpdateRequestedHook() == BLT_TRUE)
    164            {
    165              /* transition from IDLE to STARTING state, which kicks off the update sequence */
    166              firmwareUpdateState = FIRMWARE_UPDATE_STATE_STARTING;
    167              return BLT_TRUE;
    168            }
    169            /* still here so no update request pending */
    170            return BLT_FALSE;
    171          } /*** end of FileHandleFirmwareUpdateRequest ***/
    172          
    173          
    174          /***********************************************************************************//**
    175          ** \brief     File system task function for managing the firmware updates from
    176          **                 locally attached storage.
    177          ** \return    none.
    178          **
    179          ****************************************************************************************/
    180          void FileTask(void)
    181          {
    182            blt_int16s  parse_result = 0;
    183            blt_char   *read_line_ptr;
    184          
    185            /* ------------------------------- idle -------------------------------------------- */
    186            if (firmwareUpdateState == FIRMWARE_UPDATE_STATE_IDLE)
    187            {
    188              /* currently, nothings need to be done while idling */
    189            }
    190            /* ------------------------------- starting ---------------------------------------- */
    191            else if (firmwareUpdateState == FIRMWARE_UPDATE_STATE_STARTING)
    192            {
    193              /* reinit the NVM driver because a new firmware update is about the start */
    194              NvmInit();
    195          #if (BOOT_FILE_STARTED_HOOK_ENABLE > 0)
    196              /* inform application about update started event via hook function */
    197              FileFirmwareUpdateStartedHook();
    198          #endif
    199          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    200              FileFirmwareUpdateLogHook("Firmware update request detected\n\r");
    201              FileFirmwareUpdateLogHook("Opening firmware file for reading...");
    202          #endif
    203              /* attempt to obtain a file object for the firmware file */
    204              if (f_open(&fatFsObjects.file, FileGetFirmwareFilenameHook(), FA_OPEN_EXISTING | FA_READ) != FR_OK)
    205              {
    206                /* cannot continue with firmware update so go back to idle state */
    207                firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    208                /* can't open file */
    209          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    210                FileFirmwareUpdateLogHook("ERROR\n\r");
    211          #endif
    212          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    213                FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_OPEN_FIRMWARE_FILE);
    214          #endif
    215                /* nothing left to do now */
    216                return;
    217              }
    218          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    219              FileFirmwareUpdateLogHook("OK\n\r");
    220              FileFirmwareUpdateLogHook("Starting the programming sequence\n\r");
    221              FileFirmwareUpdateLogHook("Parsing firmware file to detect erase blocks...");
    222          #endif
    223              /* prepare data objects for the erasing state */
    224              eraseInfo.start_address = 0;
    225              eraseInfo.total_size = 0;
    226              /* transition from idle to erasing state */
    227              firmwareUpdateState = FIRMWARE_UPDATE_STATE_ERASING;
    228            }
    229            /* ------------------------------- erasing ----------------------------------------- */
    230            else if (firmwareUpdateState == FIRMWARE_UPDATE_STATE_ERASING)
    231            {
    232              /* read a line from the file */
    233              read_line_ptr = f_gets(lineParseObject.line, sizeof(lineParseObject.line), &fatFsObjects.file);
    234              /* check if an error occurred */
    235              if (f_error(&fatFsObjects.file) > 0)
    236              {
    237                /* cannot continue with firmware update so go back to idle state */
    238                firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    239          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    240                FileFirmwareUpdateLogHook("ERROR\n\r");
    241          #endif
    242          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    243                FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_READ_FROM_FILE);
    244          #endif
    245                /* close the file */
    246                f_close(&fatFsObjects.file);
    247                return;
    248              }
    249              /* parse the S-Record line without copying the data values if the line is not empty */
    250              if (read_line_ptr != BLT_NULL)
    251              {
    252                parse_result = FileSrecParseLine(lineParseObject.line, &lineParseObject.address, BLT_NULL);
    253                /* check parsing result */
    254                if (parse_result == ERROR_SREC_INVALID_CHECKSUM)
    255                {
    256                  /* cannot continue with firmware update so go back to idle state */
    257                  firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    258          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    259                  FileFirmwareUpdateLogHook("ERROR\n\r");
    260          #endif
    261          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    262                  FileFirmwareUpdateErrorHook(FILE_ERROR_INVALID_CHECKSUM_IN_FILE);
    263          #endif
    264                  /* close the file */
    265                  f_close(&fatFsObjects.file);
    266                  return;
    267                }
    268              }
    269              /* only process parsing results if the line contained address/data info */
    270              if (parse_result > 0)
    271              {
    272                /* is this the first address/data info we encountered? */
    273                if (eraseInfo.total_size == 0)
    274                {
    275                  /* store the start_address and byte count */
    276                  eraseInfo.start_address = lineParseObject.address;
    277                  eraseInfo.total_size = parse_result;
    278                }
    279                else
    280                {
    281                  /* does this data fit at the end of the previously detected program block? */
    282                  if (lineParseObject.address == (eraseInfo.start_address + eraseInfo.total_size))
    283                  {
    284                    /* update the byte count */
    285                    eraseInfo.total_size += parse_result;
    286                  }
    287                  else
    288                  {
    289                    /* data does not belong to the previously detected block so there must be a
    290                     * gap in the data. first erase the currently detected block and then start
    291                     * tracking a new block.
    292                     */
    293                    #if (BOOT_FILE_LOGGING_ENABLE > 0)
    294                    FileFirmwareUpdateLogHook("OK\n\r");
    295                    FileFirmwareUpdateLogHook("Erasing ");
    296                    /* convert size to string  */
    297                    FileLibLongToIntString(eraseInfo.total_size, loggingStr);
    298                    FileFirmwareUpdateLogHook(loggingStr);
    299                    FileFirmwareUpdateLogHook(" bytes from memory at 0x");
    300                    /* convert address to hex-string  */
    301                    FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 24), &loggingStr[0]);
    302                    FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 16), &loggingStr[2]);
    303                    FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 8), &loggingStr[4]);
    304                    FileLibByteToHexString((blt_int8u)eraseInfo.start_address, &loggingStr[6]);
    305                    FileFirmwareUpdateLogHook(loggingStr);
    306                    FileFirmwareUpdateLogHook("...");
    307                    #endif
    308                    /* still here so we are ready to perform the memory erase operation */
    309                    if (NvmErase(eraseInfo.start_address, eraseInfo.total_size) == BLT_FALSE)
    310                    {
    311                      /* cannot continue with firmware update so go back to idle state */
    312                      firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    313                      #if (BOOT_FILE_LOGGING_ENABLE > 0)
    314                      FileFirmwareUpdateLogHook("ERROR\n\r");
    315                      #endif
    316                      #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    317                      FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_ERASE_MEMORY);
    318                      #endif
    319                      /* close the file */
    320                      f_close(&fatFsObjects.file);
    321                      return;
    322                    }
    323                    #if (BOOT_FILE_LOGGING_ENABLE > 0)
    324                    FileFirmwareUpdateLogHook("OK\n\r");
    325                    FileFirmwareUpdateLogHook("Parsing firmware file to detect erase blocks...");
    326                    #endif
    327          
    328                    /* store the start_address and element count */
    329                    eraseInfo.start_address = lineParseObject.address;
    330                    eraseInfo.total_size = parse_result;
    331                  }
    332                }
    333              }
    334              /* check if the end of the file was reached */
    335              if (f_eof(&fatFsObjects.file) > 0)
    336              {
    337                /* rewind the file in preparation for the programming state */
    338                if (f_lseek(&fatFsObjects.file, 0) != FR_OK)
    339                {
    340                  /* cannot continue with firmware update so go back to idle state */
    341                  firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    342          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    343                  FileFirmwareUpdateLogHook("ERROR\n\r");
    344          #endif
    345          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    346                  FileFirmwareUpdateErrorHook(FILE_ERROR_REWINDING_FILE_READ_POINTER);
    347          #endif
    348                  /* close the file */
    349                  f_close(&fatFsObjects.file);
    350                  return;
    351                }
    352                /* still here so we are ready to perform the last memory erase operation, if there
    353                 * is still something left to erase.
    354                 */
    355                if (eraseInfo.total_size > 0)
    356                {
    357                  #if (BOOT_FILE_LOGGING_ENABLE > 0)
    358                  FileFirmwareUpdateLogHook("OK\n\r");
    359                  FileFirmwareUpdateLogHook("Erasing ");
    360                  /* convert size to string  */
    361                  FileLibLongToIntString(eraseInfo.total_size, loggingStr);
    362                  FileFirmwareUpdateLogHook(loggingStr);
    363                  FileFirmwareUpdateLogHook(" bytes from memory at 0x");
    364                  /* convert address to hex-string  */
    365                  FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 24), &loggingStr[0]);
    366                  FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 16), &loggingStr[2]);
    367                  FileLibByteToHexString((blt_int8u)(eraseInfo.start_address >> 8), &loggingStr[4]);
    368                  FileLibByteToHexString((blt_int8u)eraseInfo.start_address, &loggingStr[6]);
    369                  FileFirmwareUpdateLogHook(loggingStr);
    370                  FileFirmwareUpdateLogHook("...");
    371                  #endif
    372                  if (NvmErase(eraseInfo.start_address, eraseInfo.total_size) == BLT_FALSE)
    373                  {
    374                    /* cannot continue with firmware update so go back to idle state */
    375                    firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    376                    #if (BOOT_FILE_LOGGING_ENABLE > 0)
    377                    FileFirmwareUpdateLogHook("ERROR\n\r");
    378                    #endif
    379                    #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    380                    FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_ERASE_MEMORY);
    381                    #endif
    382                    /* close the file */
    383                    f_close(&fatFsObjects.file);
    384                    return;
    385                  }
    386                }
    387          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    388                FileFirmwareUpdateLogHook("OK\n\r");
    389          #endif
    390                /* all okay, then go to programming state */
    391                firmwareUpdateState = FIRMWARE_UPDATE_STATE_PROGRAMMING;
    392              }
    393            }
    394            /* ------------------------------- programming ------------------------------------- */
    395            else if (firmwareUpdateState == FIRMWARE_UPDATE_STATE_PROGRAMMING)
    396            {
    397              /* read a line from the file */
    398              read_line_ptr = f_gets(lineParseObject.line, sizeof(lineParseObject.line), &fatFsObjects.file);
    399              /* check if an error occurred */
    400              if (f_error(&fatFsObjects.file) > 0)
    401              {
    402                /* cannot continue with firmware update so go back to idle state */
    403                firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    404          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    405                FileFirmwareUpdateLogHook("Reading line from file...ERROR\n\r");
    406          #endif
    407          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    408                FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_READ_FROM_FILE);
    409          #endif
    410                /* close the file */
    411                f_close(&fatFsObjects.file);
    412                return;
    413              }
    414              /* parse the S-Record line if the line is not empty */
    415              if (read_line_ptr != BLT_NULL)
    416              {
    417                parse_result = FileSrecParseLine(lineParseObject.line, &lineParseObject.address, lineParseObject.data);
    418                /* check parsing result */
    419                if (parse_result == ERROR_SREC_INVALID_CHECKSUM)
    420                {
    421                  /* cannot continue with firmware update so go back to idle state */
    422                  firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    423          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    424                  FileFirmwareUpdateLogHook("Invalid checksum found...ERROR\n\r");
    425          #endif
    426          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    427                  FileFirmwareUpdateErrorHook(FILE_ERROR_INVALID_CHECKSUM_IN_FILE);
    428          #endif
    429                  /* close the file */
    430                  f_close(&fatFsObjects.file);
    431                  return;
    432                }
    433              }
    434              /* only process parsing results if the line contained address/data info */
    435              if (parse_result > 0)
    436              {
    437          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    438                FileFirmwareUpdateLogHook("Programming ");
    439                /* convert size to string  */
    440                FileLibLongToIntString(parse_result, loggingStr);
    441                FileFirmwareUpdateLogHook(loggingStr);
    442                FileFirmwareUpdateLogHook(" bytes to memory at 0x");
    443                /* convert address to hex-string  */
    444                FileLibByteToHexString((blt_int8u)(lineParseObject.address >> 24), &loggingStr[0]);
    445                FileLibByteToHexString((blt_int8u)(lineParseObject.address >> 16), &loggingStr[2]);
    446                FileLibByteToHexString((blt_int8u)(lineParseObject.address >> 8), &loggingStr[4]);
    447                FileLibByteToHexString((blt_int8u)lineParseObject.address, &loggingStr[6]);
    448                FileFirmwareUpdateLogHook(loggingStr);
    449                FileFirmwareUpdateLogHook("...");
    450          #endif
    451                /* program the data */
    452                if (NvmWrite(lineParseObject.address, parse_result, lineParseObject.data) == BLT_FALSE)
    453                {
    454                  /* cannot continue with firmware update so go back to idle state */
    455                  firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    456          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    457                  FileFirmwareUpdateLogHook("ERROR\n\r");
    458          #endif
    459          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    460                  FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_PROGRAM_MEMORY);
    461          #endif
    462                  /* close the file */
    463                  f_close(&fatFsObjects.file);
    464                  return;
    465                }
    466          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    467                FileFirmwareUpdateLogHook("OK\n\r");
    468          #endif
    469              }
    470              /* check if the end of the file was reached */
    471              if (f_eof(&fatFsObjects.file) > 0)
    472              {
    473          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    474                FileFirmwareUpdateLogHook("Writing program checksum...");
    475          #endif
    476                /* finish the programming by writing the checksum */
    477                if (NvmDone() == BLT_FALSE)
    478                {
    479                  /* cannot continue with firmware update so go back to idle state */
    480                  firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    481          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    482                  FileFirmwareUpdateLogHook("ERROR\n\r");
    483          #endif
    484          #if (BOOT_FILE_ERROR_HOOK_ENABLE > 0)
    485                  FileFirmwareUpdateErrorHook(FILE_ERROR_CANNOT_WRITE_CHECKSUM);
    486          #endif
    487                  /* close the file */
    488                  f_close(&fatFsObjects.file);
    489                  return;
    490                }
    491          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    492                FileFirmwareUpdateLogHook("OK\n\r");
    493                FileFirmwareUpdateLogHook("Closing firmware file\n\r");
    494          #endif
    495                /* close the file */
    496                f_close(&fatFsObjects.file);
    497          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    498                FileFirmwareUpdateLogHook("Firmware update successfully completed\n\r");
    499          #endif
    500                /* all done so transistion back to idle mode */
    501                firmwareUpdateState = FIRMWARE_UPDATE_STATE_IDLE;
    502          #if (BOOT_FILE_COMPLETED_HOOK_ENABLE > 0)
    503                /* inform application about update completed event via hook function */
    504                FileFirmwareUpdateCompletedHook();
    505          #endif
    506                /* attempt to start the user program now that programming is done */
    507                CpuStartUserProgram();
    508              }
    509            }
    510          } /*** end of FileTask ***/
    511          
    512          
    513          /************************************************************************************//**
    514          ** \brief     Inspects a line from a Motorola S-Record file to determine its type.
    515          ** \param     line A line from the S-Record.
    516          ** \return    the S-Record line type.
    517          **
    518          ****************************************************************************************/
    519          tSrecLineType FileSrecGetLineType(const blt_char *line)
    520          {
    521            /* check if the line starts with the 'S' character, followed by a digit */
    522            if ((toupper((blt_int16s)(line[0])) != 'S') || (isdigit((blt_int16s)(line[1])) == 0))
    523            {
    524              /* not a valid S-Record line type */
    525              return LINE_TYPE_UNSUPPORTED;
    526            }
    527            /* determine the line type */
    528            if (line[1] == '1')
    529            {
    530              return LINE_TYPE_S1;
    531            }
    532            if (line[1] == '2')
    533            {
    534              return LINE_TYPE_S2;
    535            }
    536            if (line[1] == '3')
    537            {
    538              return LINE_TYPE_S3;
    539            }
    540            /* still here so not a supported line type found */
    541            return LINE_TYPE_UNSUPPORTED;
    542          } /*** end of FileSrecGetLineType ***/
    543          
    544          
    545          /************************************************************************************//**
    546          ** \brief     Inspects an S1, S2 or S3 line from a Motorola S-Record file to
    547          **            determine if the checksum at the end is corrrect.
    548          ** \param     line An S1, S2 or S3 line from the S-Record.
    549          ** \return    BLT_TRUE if the checksum is correct, BLT_FALSE otherwise.
    550          **
    551          ****************************************************************************************/
    552          blt_bool FileSrecVerifyChecksum(const blt_char *line)
    553          {
    554            blt_int16u bytes_on_line;
    555            blt_int8u  checksum = 0;
    556          
    557            /* adjust pointer to point to byte count value */
    558            line += 2;
    559            /* read out the number of byte values that follow on the line */
    560            bytes_on_line = FileLibHexStringToByte(line);
    561            /* byte count is part of checksum */
    562            checksum += bytes_on_line;
    563            /* adjust pointer to the first byte of the address */
    564            line += 2;
    565            /* add byte values of address and data, but not the final checksum */
    566            do
    567            {
    568              /* add the next byte value to the checksum */
    569              checksum += FileLibHexStringToByte(line);
    570              /* update counter */
    571              bytes_on_line--;
    572              /* point to next hex string in the line */
    573              line += 2;
    574            }
    575            while (bytes_on_line > 1);
    576            /* the checksum is calculated by summing up the values of the byte count, address and
    577             * databytes and then taking the 1-complement of the sum's least signigicant byte */
    578            checksum = ~checksum;
    579            /* finally verify the calculated checksum with the one at the end of the line */
    580            if (checksum != FileLibHexStringToByte(line))
    581            {
    582              /* checksum incorrect */
    583              return BLT_FALSE;
    584            }
    585            /* still here so the checksum was correct */
    586            return BLT_TRUE;
    587          } /*** end of FileSrecVerifyChecksum ***/
    588          
    589          
    590          /************************************************************************************//**
    591          ** \brief     Parses a line from a Motorola S-Record file and looks for S1, S2 or S3
    592          **            lines with data. Note that if a null pointer is passed as the data
    593          **            parameter, then no data is extracted from the line.
    594          ** \param     line    A line from the S-Record.
    595          ** \param     address Address found in the S-Record data line.
    596          ** \param     data    Byte array where the data bytes from the S-Record data line
    597          **                    are stored.
    598          ** \return    The number of data bytes found on the S-record data line, 0 in case
    599          **            the line is not an S1, S2 or S3 line or ERROR_SREC_INVALID_CHECKSUM
    600          **            in case the checksum validation failed.
    601          **
    602          ****************************************************************************************/
    603          blt_int16s FileSrecParseLine(const blt_char *line, blt_addr *address, blt_int8u *data)
    604          {
    605            tSrecLineType lineType;
    606            blt_int16s    data_byte_count = 0;
    607            blt_int16u    bytes_on_line;
    608            blt_int16u    i;
    609          
    610            /* check pointers and not that data can be a null pointer */
    611            ASSERT_RT((address != BLT_NULL) && (line != BLT_NULL));
    612            /* figure out what type of line we are dealing with */
    613            lineType = FileSrecGetLineType(line);
    614            /* make sure it is one that we can parse */
    615            if (lineType == LINE_TYPE_UNSUPPORTED)
    616            {
    617              /* not a parsing error, but simply no data on this line */
    618              return 0;
    619            }
    620            /* verify the checksum */
    621            if (FileSrecVerifyChecksum(line) == BLT_FALSE)
    622            {
    623              /* error on data line encountered */
    624              return ERROR_SREC_INVALID_CHECKSUM;
    625            }
    626            /* all good so far, now read out the address and databytes for the line */
    627            switch (lineType)
    628            {
    629              /* ---------------------------- S1 line type ------------------------------------- */
    630              case LINE_TYPE_S1:
    631                /* adjust pointer to point to byte count value */
    632                line += 2;
    633                /* read out the number of byte values that follow on the line */
    634                bytes_on_line = FileLibHexStringToByte(line);
    635                /* read out the 16-bit address */
    636                line += 2;
    637                *address = FileLibHexStringToByte(line) << 8;
    638                line += 2;
    639                *address += FileLibHexStringToByte(line);
    640                /* adjust pointer to point to the first data byte after the address */
    641                line += 2;
    642                /* determine how many data bytes are on the line */
    643                data_byte_count = bytes_on_line - 3; /* -2 bytes address, -1 byte checksum */
    644                /* read and store data bytes if requested */
    645                if (data != BLT_NULL)
    646                {
    647                  for (i=0; i<data_byte_count; i++)
    648                  {
    649                    data[i] = FileLibHexStringToByte(line);
    650                    line += 2;
    651                  }
    652                }
    653                break;
    654          
    655              /* ---------------------------- S2 line type ------------------------------------- */
    656              case LINE_TYPE_S2:
    657                /* adjust pointer to point to byte count value */
    658                line += 2;
    659                /* read out the number of byte values that follow on the line */
    660                bytes_on_line = FileLibHexStringToByte(line);
    661                /* read out the 32-bit address */
    662                line += 2;
    663                *address = FileLibHexStringToByte(line) << 16;
    664                line += 2;
    665                *address += FileLibHexStringToByte(line) << 8;
    666                line += 2;
    667                *address += FileLibHexStringToByte(line);
    668                /* adjust pointer to point to the first data byte after the address */
    669                line += 2;
    670                /* determine how many data bytes are on the line */
    671                data_byte_count = bytes_on_line - 4; /* -3 bytes address, -1 byte checksum */
    672                /* read and store data bytes if requested */
    673                if (data != BLT_NULL)
    674                {
    675                  for (i=0; i<data_byte_count; i++)
    676                  {
    677                    data[i] = FileLibHexStringToByte(line);
    678                    line += 2;
    679                  }
    680                }
    681                break;
    682          
    683              /* ---------------------------- S3 line type ------------------------------------- */
    684              case LINE_TYPE_S3:
    685                /* adjust pointer to point to byte count value */
    686                line += 2;
    687                /* read out the number of byte values that follow on the line */
    688                bytes_on_line = FileLibHexStringToByte(line);
    689                /* read out the 32-bit address */
    690                line += 2;
    691                *address = FileLibHexStringToByte(line) << 24;
    692                line += 2;
    693                *address += FileLibHexStringToByte(line) << 16;
    694                line += 2;
    695                *address += FileLibHexStringToByte(line) << 8;
    696                line += 2;
    697                *address += FileLibHexStringToByte(line);
    698                /* adjust pointer to point to the first data byte after the address */
    699                line += 2;
    700                /* determine how many data bytes are on the line */
    701                data_byte_count = bytes_on_line - 5; /* -4 bytes address, -1 byte checksum */
    702                /* read and store data bytes if requested */
    703                if (data != BLT_NULL)
    704                {
    705                  for (i=0; i<data_byte_count; i++)
    706                  {
    707                    data[i] = FileLibHexStringToByte(line);
    708                    line += 2;
    709                  }
    710                }
    711                break;
    712          
    713              default:
    714                break;
    715            }
    716          
    717            return data_byte_count;
    718          } /*** end of FileSrecParseLine ***/
    719          
    720          
    721          #if (BOOT_FILE_LOGGING_ENABLE > 0)
    722          /************************************************************************************//**
    723          ** \brief     Helper function to convert a 4-bit value to a character that represents its
    724          **            value in hexadecimal format.
    725          **              Example: FileLibByteNibbleToChar(11)  --> returns 'B'.
    726          ** \param     nibble 4-bit value to convert.
    727          ** \return    The resulting byte value.
    728          **
    729          ****************************************************************************************/
    730          static blt_char FileLibByteNibbleToChar(blt_int8u nibble)
    731          {
    732            blt_char  c;
    733          
    734            /* convert to ASCII value */
    735            c = (nibble & 0x0f) + '0';
    736            if (nibble > 9)
    737            {
    738              c += 7;
    739            }
    740            else
    741            {
    742              c = toupper((blt_int16s)c);
    743            }
    744            /* return the character */
    745            return c;
    746          } /*** end of FileLibByteNibbleToChar ***/
    747          
    748          
    749          /************************************************************************************//**
    750          ** \brief     Helper function to convert a byte value to a string representing the
    751          **            value in hexadecimal format.
    752          **              Example: FileLibByteToHexString(28, strBuffer)  --> returns "1C".
    753          ** \param     byte_val    8-bit value to convert.
    754          ** \param     destination Pointer to character buffer for storing the results.
    755          ** \return    The resulting string.
    756          **
    757          ****************************************************************************************/
    758          static blt_char *FileLibByteToHexString(blt_int8u byte_val, blt_char *destination)
    759          {
    760            /* first the most significant n-bit nibble */
    761            destination[0] = FileLibByteNibbleToChar(byte_val >> 4);
    762            /* next the least significant n-bit nibble */
    763            destination[1] = FileLibByteNibbleToChar(byte_val & 0x0f);
    764            /* add string termination */
    765            destination[2] = '\0';
    766            /* return pointer to resulting string */
    767            return destination;
    768          } /*** end of FileLibByteToHexString ***/
    769          
    770          
    771          /************************************************************************************//**
    772          ** \brief     Helper function to convert a 32-bit unsigned number to a string that
    773          **            represents its decimal value.
    774          **              Example: FileLibLongToIntString(1234, strBuffer)  --> returns "1234".
    775          ** \param     long_val    32-bit value to convert.
    776          ** \param     destination Pointer to character buffer for storing the results.
    777          ** \return    The resulting string.
    778          **
    779          ****************************************************************************************/
    780          static blt_char *FileLibLongToIntString(blt_int32u long_val, blt_char *destination)
    781          {
    782            blt_int32u long_val_cpy = long_val;
    783          
    784            /* first determine how many digits there will be */
    785            do
    786            {
    787              destination++;
    788              long_val_cpy /= 10;
    789            }
    790            while (long_val_cpy > 0);
    791            /* add space for the string termination and add it */
    792            *destination = '\0';
    793            /* now add the digits from right to left */
    794            long_val_cpy = long_val;
    795            do
    796            {
    797              /* set write pointer to where the next character should go */
    798              destination--;
    799              /* write digit in ASCII format */
    800              *destination = long_val_cpy % 10 + '0';
    801              /* move on to the next digit */
    802              long_val_cpy /= 10;
    803            }
    804            while (long_val_cpy > 0);
    805          
    806            return destination;
    807          } /*** end of FileLibLongToIntString ***/
    808          #endif /* (BOOT_FILE_LOGGING_ENABLE > 0) */
    809          
    810          
    811          /************************************************************************************//**
    812          ** \brief     Helper function to convert a sequence of 2 characters that represent
    813          **            a hexadecimal value to the actual byte value.
    814          **              Example: FileLibHexStringToByte("2f")  --> returns 47.
    815          ** \param     hexstring String beginning with 2 characters that represent a hexa-
    816          **                      decimal value.
    817          ** \return    The resulting byte value.
    818          **
    819          ****************************************************************************************/
    820          static blt_int8u FileLibHexStringToByte(const blt_char *hexstring)
    821          {
    822            blt_int8u result = 0;
    823            blt_char  c;
    824            blt_int8u counter;
    825          
    826            /* a hexadecimal character is 2 characters long (i.e 0x4F minus the 0x part) */
    827            for (counter=0; counter < 2; counter++)
    828            {
    829              /* read out the character */
    830              c = toupper((blt_int16s)(hexstring[counter]));
    831              /* check that the character is 0..9 or A..F */
    832              if ((c < '0') || (c > 'F') || ((c > '9') && (c < 'A')))
    833              {
    834                /* character not valid */
    835                return 0;
    836              }
    837              /* convert character to 4-bit value (check ASCII table for more info) */
    838              c -= '0';
    839              if (c > 9)
    840              {
    841                c -= 7;
    842              }
    843              /* add it to the result */
    844              result = (result << 4) + c;
    845            }
    846            /* return the results */
    847            return result;
    848          } /*** end of FileLibHexStringToByte ***/
    849          
    850          #endif /* BOOT_FILE_SYS_ENABLE > 0 */
    851          
    852          
    853          /*********************************** end of file.c *************************************/


 
 
 0 bytes of memory

Errors: none
Warnings: none
