###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.1.364/W64 for ARM         06/Oct/2023  13:39:21
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        R:\STM32F205RC-Booter\Source\third_party\fatfs\src\ff.c
#    Command line      =
#        -f
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir\ff.o.rsp
#        (R:\STM32F205RC-Booter\Source\third_party\fatfs\src\ff.c -D
#        USE_HAL_DRIVER -D USE_FULL_LL_DRIVER -D STM32F205xx -lcN
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir
#        -o
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.4\arm\inc\c\DLib_Config_Normal.h" -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Device\ST\STM32F2xx\Include\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\CMSIS\Include\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\fatfs\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\lib\STM32F2xx_HAL_Driver\Inc\Legacy\
#        -I R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\ARMCM3_STM32F2\
#        -I
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\ide\..\..\..\Source\third_party\fatfs\src\
#        -Ol) --dependencies=n
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir\ff.o.iar_deps
#    Locale            =  C
#    List file         =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir\ff.lst
#    Object file       =
#        R:\STM32F205RC-Booter\Boot_MCU\Boot\obj\fatfs_8849921791639881067.dir\ff.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#
###############################################################################

R:\STM32F205RC-Booter\Source\third_party\fatfs\src\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.12                 (C)ChaN, 2016        /
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a free software that opened under license policy of
      5          / following conditions.
      6          /
      7          / Copyright (C) 2016, ChaN, all right reserved.
      8          /
      9          / 1. Redistributions of source code must retain the above copyright notice,
     10          /    this condition and the following disclaimer.
     11          /
     12          / This software is provided by the copyright holder and contributors "AS IS"
     13          / and any warranties related to this software are DISCLAIMED.
     14          / The copyright owner or contributors be NOT LIABLE for any damages caused
     15          / by use of this software.
     16          /----------------------------------------------------------------------------*/
     17          
     18          
     19          #include "ff.h"			/* Declarations of FatFs API */
     20          #include "diskio.h"		/* Declarations of disk I/O functions */
     21          
     22          
     23          /*--------------------------------------------------------------------------
     24          
     25             Module Private Definitions
     26          
     27          ---------------------------------------------------------------------------*/
     28          
     29          #if _FATFS != 88100	/* Revision ID */
     30          #error Wrong include file (ff.h).
     31          #endif
     32          
     33          
     34          /* Reentrancy related */
     35          #if _FS_REENTRANT
     36          #if _USE_LFN == 1
     37          #error Static LFN work area cannot be used at thread-safe configuration
     38          #endif
     39          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     40          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
     41          #else
     42          #define	ENTER_FF(fs)
     43          #define LEAVE_FF(fs, res)	return res
     44          #endif
     45          
     46          #define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
     47          
     48          
     49          /* Definitions of sector size */
     50          #if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
     51          #error Wrong sector size configuration
     52          #endif
     53          #if _MAX_SS == _MIN_SS
     54          #define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
     55          #else
     56          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
     57          #endif
     58          
     59          
     60          /* Timestamp */
     61          #if _FS_NORTC == 1
     62          #if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
     63          #error Invalid _FS_NORTC settings
     64          #endif
     65          #define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
     66          #else
     67          #define GET_FATTIME()	get_fattime()
     68          #endif
     69          
     70          
     71          /* File lock controls */
     72          #if _FS_LOCK != 0
     73          #if _FS_READONLY
     74          #error _FS_LOCK must be 0 at read-only configuration
     75          #endif
     76          typedef struct {
     77          	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
     78          	DWORD clu;		/* Object ID 2, directory (0:root) */
     79          	DWORD ofs;		/* Object ID 3, directory offset */
     80          	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
     81          } FILESEM;
     82          #endif
     83          
     84          
     85          
     86          /* DBCS code ranges and SBCS upper conversion tables */
     87          
     88          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
     89          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
     90          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
     91          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
     92          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
     93          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
     94          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
     95          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
     96          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
     97          
     98          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
     99          #define _DF1S	0x81
    100          #define _DF1E	0xFE
    101          #define _DS1S	0x40
    102          #define _DS1E	0x7E
    103          #define _DS2S	0x80
    104          #define _DS2E	0xFE
    105          
    106          #elif _CODE_PAGE == 949	/* Korean */
    107          #define _DF1S	0x81
    108          #define _DF1E	0xFE
    109          #define _DS1S	0x41
    110          #define _DS1E	0x5A
    111          #define _DS2S	0x61
    112          #define _DS2E	0x7A
    113          #define _DS3S	0x81
    114          #define _DS3E	0xFE
    115          
    116          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    117          #define _DF1S	0x81
    118          #define _DF1E	0xFE
    119          #define _DS1S	0x40
    120          #define _DS1E	0x7E
    121          #define _DS2S	0xA1
    122          #define _DS2E	0xFE
    123          
    124          #elif _CODE_PAGE == 437	/* U.S. */
    125          #define _DF1S	0
    126          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    127          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    128          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    129          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    130          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    131          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    132          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    133          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    134          
    135          #elif _CODE_PAGE == 720	/* Arabic */
    136          #define _DF1S	0
    137          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    138          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    139          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    140          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    141          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    142          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    143          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    144          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    145          
    146          #elif _CODE_PAGE == 737	/* Greek */
    147          #define _DF1S	0
    148          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    149          				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    150          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
    151          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    152          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    153          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    154          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    155          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    156          
    157          #elif _CODE_PAGE == 771	/* KBL */
    158          #define _DF1S	0
    159          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    160          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    161          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    162          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    163          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    164          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
    165          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    166          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
    167          
    168          #elif _CODE_PAGE == 775	/* Baltic */
    169          #define _DF1S	0
    170          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
    171          				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    172          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    173          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    174          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    175          				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    176          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
    177          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    178          
    179          #elif _CODE_PAGE == 850	/* Latin 1 */
    180          #define _DF1S	0
    181          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
    182          				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
    183          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    184          				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    185          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    186          				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
    187          				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
    188          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    189          
    190          #elif _CODE_PAGE == 852	/* Latin 2 */
    191          #define _DF1S	0
    192          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
    193          				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
    194          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
    195          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    196          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    197          				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
    199          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    200          
    201          #elif _CODE_PAGE == 855	/* Cyrillic */
    202          #define _DF1S	0
    203          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
    204          				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    205          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
    206          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    207          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    208          				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    209          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
    210          				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 857	/* Turkish */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
    215          				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    216          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    217          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    219          				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    220          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
    221          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    222          
    223          #elif _CODE_PAGE == 860	/* Portuguese */
    224          #define _DF1S	0
    225          #define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
    226          				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    227          				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    228          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    229          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    230          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    232          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    233          
    234          #elif _CODE_PAGE == 861	/* Icelandic */
    235          #define _DF1S	0
    236          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
    237          				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    238          				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    239          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    240          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    241          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    242          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    243          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    244          
    245          #elif _CODE_PAGE == 862	/* Hebrew */
    246          #define _DF1S	0
    247          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    248          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    249          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    250          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    252          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    253          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    254          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 863	/* Canadian-French */
    257          #define _DF1S	0
    258          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
    259          				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
    260          				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    261          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    262          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    263          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    264          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    265          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    266          
    267          #elif _CODE_PAGE == 864	/* Arabic */
    268          #define _DF1S	0
    269          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    270          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    272          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    273          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    274          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    276          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    277          
    278          #elif _CODE_PAGE == 865	/* Nordic */
    279          #define _DF1S	0
    280          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    281          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    282          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    283          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    284          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    285          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    286          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    287          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    288          
    289          #elif _CODE_PAGE == 866	/* Russian */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    292          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    293          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    294          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    296          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    297          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    298          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    299          
    300          #elif _CODE_PAGE == 869	/* Greek 2 */
    301          #define _DF1S	0
    302          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    303          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
    304          				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    305          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    306          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    307          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
    308          				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
    309          				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
    310          
    311          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    312          #if _USE_LFN != 0
    313          #error Cannot enable LFN without valid code page.
    314          #endif
    315          #define _DF1S	0
    316          
    317          #else
    318          #error Unknown code page
    319          
    320          #endif
    321          
    322          
    323          /* Character code support macros */
    324          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    325          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    326          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    327          
    328          #if _DF1S != 0	/* Code page is DBCS */
    329          
    330          #ifdef _DF2S	/* Two 1st byte areas */
    331          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    332          #else			/* One 1st byte area */
    333          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    334          #endif
    335          
    336          #ifdef _DS3S	/* Three 2nd byte areas */
    337          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    338          #else			/* Two 2nd byte areas */
    339          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    340          #endif
    341          
    342          #else			/* Code page is SBCS */
    343          
    344          #define IsDBCS1(c)	0
    345          #define IsDBCS2(c)	0
    346          
    347          #endif /* _DF1S */
    348          
    349          
    350          /* Name status flags */
    351          #define NSFLAG		11		/* Index of name status byte in fn[] */
    352          #define NS_LOSS		0x01	/* Out of 8.3 format */
    353          #define NS_LFN		0x02	/* Force to create LFN entry */
    354          #define NS_LAST		0x04	/* Last segment */
    355          #define NS_BODY		0x08	/* Lower case flag (body) */
    356          #define NS_EXT		0x10	/* Lower case flag (ext) */
    357          #define NS_DOT		0x20	/* Dot entry */
    358          #define NS_NONAME	0x80	/* Not followed */
    359          
    360          
    361          /* Limits and Boundaries (Differ from specs but correct for real DOS/Windows) */
    362          #define MIN_FAT16	4086U			/* Minimum number of clusters of FAT16 */
    363          #define	MIN_FAT32	65526U			/* Minimum number of clusters of FAT32 */
    364          #define MAX_DIR		0x200000		/* Maximum size of FAT directory */
    365          #define MAX_DIR_EX	0x10000000		/* Maximum size of exFAT directory */
    366          
    367          
    368          /* FatFs refers the members in the FAT structures as byte array instead of
    369          / structure members because the structure is not binary compatible between
    370          / different platforms */
    371          
    372          #define BS_jmpBoot			0		/* x86 jump instruction (3-byte) */
    373          #define BS_OEMName			3		/* OEM name (8-byte) */
    374          #define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
    375          #define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
    376          #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
    377          #define BPB_NumFATs			16		/* Number of FATs (BYTE) */
    378          #define BPB_RootEntCnt		17		/* Size of root directory area for FAT12/16 [entry] (WORD) */
    379          #define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
    380          #define BPB_Media			21		/* Media descriptor (BYTE) */
    381          #define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
    382          #define BPB_SecPerTrk		24		/* Track size for int13h [sector] (WORD) */
    383          #define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
    384          #define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
    385          #define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
    386          #define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
    387          #define BS_NTres			37		/* Error flag (BYTE) */
    388          #define BS_BootSig			38		/* Extended boot signature (BYTE) */
    389          #define BS_VolID			39		/* Volume serial number (DWORD) */
    390          #define BS_VolLab			43		/* Volume label string (8-byte) */
    391          #define BS_FilSysType		54		/* File system type string (8-byte) */
    392          #define BPB_FATSz32			36		/* FAT size (32-bit) [sector] (DWORD) */
    393          #define BPB_ExtFlags		40		/* Extended flags (WORD) */
    394          
    395          #define BPB_FSVer32			42		/* FAT32: File system version (WORD) */
    396          #define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
    397          #define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
    398          #define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
    399          #define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
    400          #define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
    401          #define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
    402          #define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
    403          #define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
    404          #define BS_FilSysType32		82		/* FAT32: File system type string (8-byte) */
    405          
    406          #define BPB_ZeroedEx		11		/* exFAT: Must be zero (35-byte) */
    407          #define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
    408          #define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
    409          #define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
    410          #define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
    411          #define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
    412          #define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
    413          #define BPB_RootClusEx		96		/* exFAT: Root directory cluster (DWORD) */
    414          #define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
    415          #define BPB_FSVerEx			104		/* exFAT: File system version (WORD) */
    416          #define BPB_VolFlagEx		106		/* exFAT: Volume flags (BYTE) */
    417          #define BPB_ActFatEx		107		/* exFAT: Active FAT flags (BYTE) */
    418          #define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in byte (BYTE) */
    419          #define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in sector (BYTE) */
    420          #define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
    421          #define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
    422          #define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
    423          
    424          #define	FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
    425          #define	FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
    426          #define	FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
    427          #define	FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
    428          
    429          #define MBR_Table			446		/* MBR: Partition table offset */
    430          #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
    431          
    432          #define BS_55AA				510		/* Signature word (WORD) */
    433          
    434          #define	DIR_Name			0		/* Short file name (11) */
    435          #define	DIR_Attr			11		/* Attribute (1) */
    436          #define	DIR_NTres			12		/* Lower case flag (1) */
    437          #define DIR_CrtTime10		13		/* Created time sub-second (1) */
    438          #define	DIR_CrtTime			14		/* Created time (2) */
    439          #define	DIR_CrtDate			16		/* Created date (2) */
    440          #define DIR_LstAccDate		18		/* Last accessed date (2) */
    441          #define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
    442          #define	DIR_WrtTime			22		/* Modified time (2) */
    443          #define	DIR_WrtDate			24		/* Modified date (2) */
    444          #define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
    445          #define	DIR_FileSize		28		/* File size (DWORD) */
    446          #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
    447          #define	LDIR_Attr			11		/* LFN attribute (1) */
    448          #define	LDIR_Type			12		/* LFN type (1) */
    449          #define	LDIR_Chksum			13		/* Checksum of the SFN entry */
    450          #define	LDIR_FstClusLO		26		/* Must be zero (WORD) */
    451          #define	XDIR_Type			0		/* Type of exFAT directory entry (BYTE) */
    452          #define	XDIR_NumLabel		1		/* Number of volume label characters (BYTE) */
    453          #define	XDIR_Label			2		/* Volume label (11-WORD) */
    454          #define	XDIR_CaseSum		4		/* Sum of case conversion table (DWORD) */
    455          #define	XDIR_NumSec			1		/* Number of secondary entries (BYTE) */
    456          #define	XDIR_SetSum			2		/* Sum of the set of directory entries (WORD) */
    457          #define	XDIR_Attr			4		/* File attribute (WORD) */
    458          #define	XDIR_CrtTime		8		/* Created time (4) */
    459          #define	XDIR_ModTime		12		/* Modified time (4) */
    460          #define	XDIR_AccTime		16		/* Last accessed time (4) */
    461          #define	XDIR_CrtTime10		20		/* Created time subsecond (1) */
    462          #define	XDIR_ModTime10		21		/* Modified time subsecond (1) */
    463          #define	XDIR_CrtTZ			22		/* Created timezone (1) */
    464          #define	XDIR_ModTZ			23		/* Modified timezone (1) */
    465          #define	XDIR_AccTZ			24		/* Last accessed timezone (1) */
    466          #define	XDIR_GenFlags		33		/* Gneral flags (1) */
    467          #define	XDIR_NumName		35		/* Number of file name characters (BYTE) */
    468          #define	XDIR_NameHash		36		/* Hash of file name (WORD) */
    469          #define XDIR_ValidFileSize	40		/* Valid file size (QWORD) */
    470          #define	XDIR_FstClus		52		/* First cluster of the File/Directory (DWORD) */
    471          #define	XDIR_FileSize		56		/* File/Directory size (QWORD) */
    472          
    473          #define	SZDIRE				32		/* Size of a directory entry */
    474          #define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
    475          #define	DDEM				0xE5	/* Deleted directory entry mark at DIR_Name[0] */
    476          #define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
    477          
    478          
    479          
    480          
    481          
    482          /*--------------------------------------------------------------------------
    483          
    484             Module Private Work Area
    485          
    486          ---------------------------------------------------------------------------*/
    487          
    488          /* Remark: Variables here without initial value shall be guaranteed zero/null
    489          /  at start-up. If not, either the linker or start-up routine being used is
    490          /  not compliance with C standard. */
    491          
    492          #if _VOLUMES < 1 || _VOLUMES > 9
    493          #error Wrong _VOLUMES setting
    494          #endif
    495          static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
    496          static WORD Fsid;				/* File system mount ID */
    497          
    498          #if _FS_RPATH != 0 && _VOLUMES >= 2
    499          static BYTE CurrVol;			/* Current drive */
    500          #endif
    501          
    502          #if _FS_LOCK != 0
    503          static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
    504          #endif
    505          
    506          #if _USE_LFN == 0			/* Non-LFN configuration */
    507          #define	DEF_NAMBUF			BYTE sfn[12]
    508          #define INIT_NAMBUF(dobj)	(dobj).fn = sfn
    509          #define	FREE_NAMBUF()
    510          #define	DEF_DIRBUF
    511          #define INIT_DIRBUF(fs)
    512          #define	FREE_DIRBUF()
    513          #else
    514          #if _MAX_LFN < 12 || _MAX_LFN > 255
    515          #error Wrong _MAX_LFN setting
    516          #endif
    517          
    518          #if _USE_LFN == 1		/* LFN enabled with static working buffer */
    519          #if _FS_EXFAT
    520          static BYTE	DirBuf[SZDIRE*19];	/* Directory entry block scratchpad buffer (19 entries in size) */
    521          #endif
    522          static WCHAR LfnBuf[_MAX_LFN+1];	/* LFN enabled with static working buffer */
    523          #define	DEF_NAMBUF		BYTE sfn[12]
    524          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = LfnBuf; }
    525          #define	FREE_NAMBUF()
    526          #define	DEF_DIRBUF
    527          #define INIT_DIRBUF(fs)
    528          #define	FREE_DIRBUF()
    529          
    530          #elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
    531          #if _FS_EXFAT
    532          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]; BYTE dbuf[SZDIRE*19]
    533          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; (dj).obj.fs->dirbuf = dbuf; }
    534          #define	FREE_NAMBUF()
    535          #define	DEF_DIRBUF		BYTE dbuf[SZDIRE*19]
    536          #define INIT_DIRBUF(fs)	fs->dirbuf = dbuf
    537          #define	FREE_DIRBUF()
    538          #else
    539          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    540          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; }
    541          #define	FREE_NAMBUF()
    542          #define	DEF_DIRBUF
    543          #define INIT_DIRBUF(fs)
    544          #define	FREE_DIRBUF()
    545          #endif
    546          
    547          #elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
    548          #if _FS_EXFAT
    549          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
    550          #define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2 + SZDIRE*19); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; (dj).obj.fs->dirbuf = (BYTE*)(lfn+_MAX_LFN+1); }
    551          #define	FREE_NAMBUF()	ff_memfree(lfn)
    552          #define	DEF_DIRBUF		BYTE *dirb
    553          #define INIT_DIRBUF(fs)	{ dirb = ff_memalloc(SZDIRE*19); if (!dirb) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); fs->dirbuf = dirb; }
    554          #define	FREE_DIRBUF()	ff_memfree(dirb)
    555          #else
    556          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
    557          #define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; }
    558          #define	FREE_NAMBUF()	ff_memfree(lfn)
    559          #define	DEF_DIRBUF
    560          #define INIT_DIRBUF(fs)
    561          #define	FREE_DIRBUF()
    562          #endif
    563          
    564          #else
    565          #error Wrong _USE_LFN setting
    566          #endif
    567          #endif
    568          
    569          #ifdef _EXCVT
    570          static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
    571          #endif
    572          
    573          
    574          
    575          
    576          
    577          
    578          /*--------------------------------------------------------------------------
    579          
    580             Module Private Functions
    581          
    582          ---------------------------------------------------------------------------*/
    583          
    584          
    585          /*-----------------------------------------------------------------------*/
    586          /* Load/Store multi-byte word in the FAT structure                       */
    587          /*-----------------------------------------------------------------------*/
    588          
    589          static
    590          WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
    591          {
    592          	WORD rv;
    593          
    594          	rv = ptr[1];
    595          	rv = rv << 8 | ptr[0];
    596          	return rv;
    597          }
    598          
    599          static
    600          DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
    601          {
    602          	DWORD rv;
    603          
    604          	rv = ptr[3];
    605          	rv = rv << 8 | ptr[2];
    606          	rv = rv << 8 | ptr[1];
    607          	rv = rv << 8 | ptr[0];
    608          	return rv;
    609          }
    610          
    611          #if _FS_EXFAT
    612          static
    613          QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
    614          {
    615          	QWORD rv;
    616          
    617          	rv = ptr[7];
    618          	rv = rv << 8 | ptr[6];
    619          	rv = rv << 8 | ptr[5];
    620          	rv = rv << 8 | ptr[4];
    621          	rv = rv << 8 | ptr[3];
    622          	rv = rv << 8 | ptr[2];
    623          	rv = rv << 8 | ptr[1];
    624          	rv = rv << 8 | ptr[0];
    625          	return rv;
    626          }
    627          #endif
    628          
    629          #if !_FS_READONLY
    630          static
    631          void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
    632          {
    633          	*ptr++ = (BYTE)val; val >>= 8;
    634          	*ptr++ = (BYTE)val;
    635          }
    636          
    637          static
    638          void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
    639          {
    640          	*ptr++ = (BYTE)val; val >>= 8;
    641          	*ptr++ = (BYTE)val; val >>= 8;
    642          	*ptr++ = (BYTE)val; val >>= 8;
    643          	*ptr++ = (BYTE)val;
    644          }
    645          
    646          #if _FS_EXFAT
    647          static
    648          void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
    649          {
    650          	*ptr++ = (BYTE)val; val >>= 8;
    651          	*ptr++ = (BYTE)val; val >>= 8;
    652          	*ptr++ = (BYTE)val; val >>= 8;
    653          	*ptr++ = (BYTE)val; val >>= 8;
    654          	*ptr++ = (BYTE)val; val >>= 8;
    655          	*ptr++ = (BYTE)val; val >>= 8;
    656          	*ptr++ = (BYTE)val; val >>= 8;
    657          	*ptr++ = (BYTE)val;
    658          }
    659          #endif
    660          #endif	/* !_FS_READONLY */
    661          
    662          
    663          
    664          /*-----------------------------------------------------------------------*/
    665          /* String functions                                                      */
    666          /*-----------------------------------------------------------------------*/
    667          
    668          /* Copy memory to memory */
    669          static
    670          void mem_cpy (void* dst, const void* src, UINT cnt) {
    671          	BYTE *d = (BYTE*)dst;
    672          	const BYTE *s = (const BYTE*)src;
    673          
    674          	if (cnt) {
    675          		do *d++ = *s++; while (--cnt);
    676          	}
    677          }
    678          
    679          /* Fill memory block */
    680          static
    681          void mem_set (void* dst, int val, UINT cnt) {
    682          	BYTE *d = (BYTE*)dst;
    683          
    684          	do *d++ = (BYTE)val; while (--cnt);
    685          }
    686          
    687          /* Compare memory block */
    688          static
    689          int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
    690          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    691          	int r = 0;
    692          
    693          	do {
    694          		r = *d++ - *s++;
    695          	} while (--cnt && r == 0);
    696          
    697          	return r;
    698          }
    699          
    700          /* Check if chr is contained in the string */
    701          static
    702          int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
    703          	while (*str && *str != chr) str++;
    704          	return *str;
    705          }
    706          
    707          
    708          
    709          
    710          /*-----------------------------------------------------------------------*/
    711          /* Request/Release grant to access the volume                            */
    712          /*-----------------------------------------------------------------------*/
    713          #if _FS_REENTRANT
    714          static
    715          int lock_fs (
    716          	FATFS* fs		/* File system object */
    717          )
    718          {
    719          	return ff_req_grant(fs->sobj);
    720          }
    721          
    722          
    723          static
    724          void unlock_fs (
    725          	FATFS* fs,		/* File system object */
    726          	FRESULT res		/* Result code to be returned */
    727          )
    728          {
    729          	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
    730          		ff_rel_grant(fs->sobj);
    731          	}
    732          }
    733          #endif
    734          
    735          
    736          
    737          
    738          /*-----------------------------------------------------------------------*/
    739          /* File lock control functions                                           */
    740          /*-----------------------------------------------------------------------*/
    741          #if _FS_LOCK != 0
    742          
    743          static
    744          FRESULT chk_lock (	/* Check if the file can be accessed */
    745          	DIR* dp,		/* Directory object pointing the file to be checked */
    746          	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
    747          )
    748          {
    749          	UINT i, be;
    750          
    751          	/* Search file semaphore table */
    752          	for (i = be = 0; i < _FS_LOCK; i++) {
    753          		if (Files[i].fs) {	/* Existing entry */
    754          			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
    755          				Files[i].clu == dp->obj.sclust &&
    756          				Files[i].ofs == dp->dptr) break;
    757          		} else {			/* Blank entry */
    758          			be = 1;
    759          		}
    760          	}
    761          	if (i == _FS_LOCK) {	/* The object is not opened */
    762          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
    763          	}
    764          
    765          	/* The object has been opened. Reject any open against writing file and all write mode open */
    766          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    767          }
    768          
    769          
    770          static
    771          int enq_lock (void)	/* Check if an entry is available for a new object */
    772          {
    773          	UINT i;
    774          
    775          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    776          	return (i == _FS_LOCK) ? 0 : 1;
    777          }
    778          
    779          
    780          static
    781          UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
    782          	DIR* dp,	/* Directory object pointing the file to register or increment */
    783          	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    784          )
    785          {
    786          	UINT i;
    787          
    788          
    789          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
    790          		if (Files[i].fs == dp->obj.fs &&
    791          			Files[i].clu == dp->obj.sclust &&
    792          			Files[i].ofs == dp->dptr) break;
    793          	}
    794          
    795          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    796          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    797          		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
    798          		Files[i].fs = dp->obj.fs;
    799          		Files[i].clu = dp->obj.sclust;
    800          		Files[i].ofs = dp->dptr;
    801          		Files[i].ctr = 0;
    802          	}
    803          
    804          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    805          
    806          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    807          
    808          	return i + 1;
    809          }
    810          
    811          
    812          static
    813          FRESULT dec_lock (	/* Decrement object open counter */
    814          	UINT i			/* Semaphore index (1..) */
    815          )
    816          {
    817          	WORD n;
    818          	FRESULT res;
    819          
    820          
    821          	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
    822          		n = Files[i].ctr;
    823          		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
    824          		if (n > 0) n--;				/* Decrement read mode open count */
    825          		Files[i].ctr = n;
    826          		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
    827          		res = FR_OK;
    828          	} else {
    829          		res = FR_INT_ERR;			/* Invalid index nunber */
    830          	}
    831          	return res;
    832          }
    833          
    834          
    835          static
    836          void clear_lock (	/* Clear lock entries of the volume */
    837          	FATFS *fs
    838          )
    839          {
    840          	UINT i;
    841          
    842          	for (i = 0; i < _FS_LOCK; i++) {
    843          		if (Files[i].fs == fs) Files[i].fs = 0;
    844          	}
    845          }
    846          #endif
    847          
    848          
    849          
    850          
    851          /*-----------------------------------------------------------------------*/
    852          /* Move/Flush disk access window in the file system object               */
    853          /*-----------------------------------------------------------------------*/
    854          #if !_FS_READONLY
    855          static
    856          FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
    857          	FATFS* fs			/* File system object */
    858          )
    859          {
    860          	DWORD wsect;
    861          	UINT nf;
    862          	FRESULT res = FR_OK;
    863          
    864          
    865          	if (fs->wflag) {	/* Write back the sector if it is dirty */
    866          		wsect = fs->winsect;	/* Current sector number */
    867          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
    868          			res = FR_DISK_ERR;
    869          		} else {
    870          			fs->wflag = 0;
    871          			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
    872          				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    873          					wsect += fs->fsize;
    874          					disk_write(fs->drv, fs->win, wsect, 1);
    875          				}
    876          			}
    877          		}
    878          	}
    879          	return res;
    880          }
    881          #endif
    882          
    883          
    884          static
    885          FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
    886          	FATFS* fs,			/* File system object */
    887          	DWORD sector		/* Sector number to make appearance in the fs->win[] */
    888          )
    889          {
    890          	FRESULT res = FR_OK;
    891          
    892          
    893          	if (sector != fs->winsect) {	/* Window offset changed? */
    894          #if !_FS_READONLY
    895          		res = sync_window(fs);		/* Write-back changes */
    896          #endif
    897          		if (res == FR_OK) {			/* Fill sector window with new data */
    898          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
    899          				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
    900          				res = FR_DISK_ERR;
    901          			}
    902          			fs->winsect = sector;
    903          		}
    904          	}
    905          	return res;
    906          }
    907          
    908          
    909          
    910          
    911          /*-----------------------------------------------------------------------*/
    912          /* Synchronize file system and strage device                             */
    913          /*-----------------------------------------------------------------------*/
    914          #if !_FS_READONLY
    915          static
    916          FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
    917          	FATFS* fs		/* File system object */
    918          )
    919          {
    920          	FRESULT res;
    921          
    922          
    923          	res = sync_window(fs);
    924          	if (res == FR_OK) {
    925          		/* Update FSInfo sector if needed */
    926          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    927          			/* Create FSInfo structure */
    928          			mem_set(fs->win, 0, SS(fs));
    929          			st_word(fs->win + BS_55AA, 0xAA55);
    930          			st_dword(fs->win + FSI_LeadSig, 0x41615252);
    931          			st_dword(fs->win + FSI_StrucSig, 0x61417272);
    932          			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
    933          			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
    934          			/* Write it into the FSInfo sector */
    935          			fs->winsect = fs->volbase + 1;
    936          			disk_write(fs->drv, fs->win, fs->winsect, 1);
    937          			fs->fsi_flag = 0;
    938          		}
    939          		/* Make sure that no pending write process in the physical drive */
    940          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
    941          	}
    942          
    943          	return res;
    944          }
    945          #endif
    946          
    947          
    948          
    949          
    950          /*-----------------------------------------------------------------------*/
    951          /* Get sector# from cluster#                                             */
    952          /*-----------------------------------------------------------------------*/
    953          
    954          static
    955          DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
    956          	FATFS* fs,		/* File system object */
    957          	DWORD clst		/* Cluster# to be converted */
    958          )
    959          {
    960          	clst -= 2;
    961          	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
    962          	return clst * fs->csize + fs->database;
    963          }
    964          
    965          
    966          
    967          
    968          /*-----------------------------------------------------------------------*/
    969          /* FAT access - Read value of a FAT entry                                */
    970          /*-----------------------------------------------------------------------*/
    971          
    972          static
    973          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
    974          	_FDID* obj,	/* Corresponding object */
    975          	DWORD clst	/* Cluster number to get the value */
    976          )
    977          {
    978          	UINT wc, bc;
    979          	DWORD val;
    980          	FATFS *fs = obj->fs;
    981          
    982          
    983          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
    984          		val = 1;	/* Internal error */
    985          
    986          	} else {
    987          		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    988          
    989          		switch (fs->fs_type) {
    990          		case FS_FAT12 :
    991          			bc = (UINT)clst; bc += bc / 2;
    992          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    993          			wc = fs->win[bc++ % SS(fs)];
    994          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    995          			wc |= fs->win[bc % SS(fs)] << 8;
    996          			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
    997          			break;
    998          
    999          		case FS_FAT16 :
   1000          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   1001          			val = ld_word(&fs->win[clst * 2 % SS(fs)]);
   1002          			break;
   1003          
   1004          		case FS_FAT32 :
   1005          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   1006          			val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x0FFFFFFF;
   1007          			break;
   1008          #if _FS_EXFAT
   1009          		case FS_EXFAT :
   1010          			if (obj->objsize) {
   1011          				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
   1012          				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
   1013          
   1014          				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
   1015          					if (cofs <= clen) {
   1016          						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
   1017          						break;
   1018          					}
   1019          				}
   1020          				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
   1021          					val = clst + 1; 	/* Generate the value */
   1022          					break;
   1023          				}
   1024          				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
   1025          					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   1026          					val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x7FFFFFFF;
   1027          					break;
   1028          				}
   1029          			}
   1030          			/* Go default */
   1031          #endif
   1032          		default:
   1033          			val = 1;	/* Internal error */
   1034          		}
   1035          	}
   1036          
   1037          	return val;
   1038          }
   1039          
   1040          
   1041          
   1042          
   1043          /*-----------------------------------------------------------------------*/
   1044          /* FAT access - Change value of a FAT entry                              */
   1045          /*-----------------------------------------------------------------------*/
   1046          
   1047          #if !_FS_READONLY
   1048          static
   1049          FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
   1050          	FATFS* fs,		/* Corresponding object */
   1051          	DWORD clst,		/* FAT index number (cluster number) to be changed */
   1052          	DWORD val		/* New value to be set to the entry */
   1053          )
   1054          {
   1055          	UINT bc;
   1056          	BYTE *p;
   1057          	FRESULT res = FR_INT_ERR;
   1058          
   1059          
   1060          	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
   1061          		switch (fs->fs_type) {
   1062          		case FS_FAT12 :	/* Bitfield items */
   1063          			bc = (UINT)clst; bc += bc / 2;
   1064          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1065          			if (res != FR_OK) break;
   1066          			p = &fs->win[bc++ % SS(fs)];
   1067          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   1068          			fs->wflag = 1;
   1069          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1070          			if (res != FR_OK) break;
   1071          			p = &fs->win[bc % SS(fs)];
   1072          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   1073          			fs->wflag = 1;
   1074          			break;
   1075          
   1076          		case FS_FAT16 :	/* WORD aligned items */
   1077          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   1078          			if (res != FR_OK) break;
   1079          			st_word(&fs->win[clst * 2 % SS(fs)], (WORD)val);
   1080          			fs->wflag = 1;
   1081          			break;
   1082          
   1083          		case FS_FAT32 :	/* DWORD aligned items */
   1084          #if _FS_EXFAT
   1085          		case FS_EXFAT :
   1086          #endif
   1087          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   1088          			if (res != FR_OK) break;
   1089          			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1090          				val = (val & 0x0FFFFFFF) | (ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0xF0000000);
   1091          			}
   1092          			st_dword(&fs->win[clst * 4 % SS(fs)], val);
   1093          			fs->wflag = 1;
   1094          			break;
   1095          		}
   1096          	}
   1097          	return res;
   1098          }
   1099          #endif /* !_FS_READONLY */
   1100          
   1101          
   1102          
   1103          
   1104          #if _FS_EXFAT && !_FS_READONLY
   1105          /*-----------------------------------------------------------------------*/
   1106          /* exFAT: Accessing FAT and Allocation Bitmap                            */
   1107          /*-----------------------------------------------------------------------*/
   1108          
   1109          /*---------------------------------------------*/
   1110          /* exFAT: Find a contiguous free cluster block */
   1111          /*---------------------------------------------*/
   1112          static
   1113          DWORD find_bitmap (	/* 0:No free cluster, 2..:Free cluster found, 0xFFFFFFFF:Disk error */
   1114          	FATFS* fs,	/* File system object */
   1115          	DWORD clst,	/* Cluster number to scan from */
   1116          	DWORD ncl	/* Number of contiguous clusters to find (1..) */
   1117          )
   1118          {
   1119          	BYTE bm, bv;
   1120          	UINT i;
   1121          	DWORD val, scl, ctr;
   1122          
   1123          
   1124          	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
   1125          	if (clst >= fs->n_fatent - 2) clst = 0;
   1126          	scl = val = clst; ctr = 0;
   1127          	for (;;) {
   1128          		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
   1129          		i = val / 8 & (SS(fs) - 1); bm = 1 << (val % 8);
   1130          		do {
   1131          			do {
   1132          				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
   1133          				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
   1134          					val = 0; bm = 0; i = 4096;
   1135          				}
   1136          				if (!bv) {	/* Is it a free cluster? */
   1137          					if (++ctr == ncl) return scl + 2;	/* Check run length */
   1138          				} else {
   1139          					scl = val; ctr = 0;		/* Encountered a live cluster, restart to scan */
   1140          				}
   1141          				if (val == clst) return 0;	/* All cluster scanned? */
   1142          			} while (bm);
   1143          			bm = 1;
   1144          		} while (++i < SS(fs));
   1145          	}
   1146          }
   1147          
   1148          /*------------------------------------*/
   1149          /* exFAT: Set/Clear a block of bitmap */
   1150          /*------------------------------------*/
   1151          static
   1152          FRESULT change_bitmap (
   1153          	FATFS* fs,	/* File system object */
   1154          	DWORD clst,	/* Cluster number to change from */
   1155          	DWORD ncl,	/* Number of clusters to be changed */
   1156          	int bv		/* bit value to be set (0 or 1) */
   1157          )
   1158          {
   1159          	BYTE bm;
   1160          	UINT i;
   1161          	DWORD sect;
   1162          
   1163          
   1164          	clst -= 2;	/* The first bit corresponds to cluster #2 */
   1165          	sect = fs->database + clst / 8 / SS(fs);	/* Sector address */
   1166          	i = clst / 8 & (SS(fs) - 1);				/* Byte offset in the sector */
   1167          	bm = 1 << (clst % 8);						/* Bit mask in the byte */
   1168          	for (;;) {
   1169          		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
   1170          		do {
   1171          			do {
   1172          				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
   1173          				fs->win[i] ^= bm;	/* Flip the bit */
   1174          				fs->wflag = 1;
   1175          				if (--ncl == 0) return FR_OK;	/* All bits processed? */
   1176          			} while (bm <<= 1);		/* Next bit */
   1177          			bm = 1;
   1178          		} while (++i < SS(fs));		/* Next byte */
   1179          	}
   1180          }
   1181          
   1182          
   1183          /*---------------------------------------------*/
   1184          /* Complement contiguous part of the FAT chain */
   1185          /*---------------------------------------------*/
   1186          static
   1187          FRESULT fill_fat_chain (
   1188          	_FDID* obj	/* Pointer to the corresponding object */
   1189          )
   1190          {
   1191          	FRESULT res;
   1192          	DWORD cl, n;
   1193          
   1194          	if (obj->stat == 3) {	/* Has the object got fragmented? */
   1195          		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
   1196          			res = put_fat(obj->fs, cl, cl + 1);
   1197          			if (res != FR_OK) return res;
   1198          		}
   1199          		obj->stat = 0;	/* Change status 'FAT chain is valid' */
   1200          	}
   1201          	return FR_OK;
   1202          }
   1203          
   1204          #endif
   1205          
   1206          
   1207          
   1208          /*-----------------------------------------------------------------------*/
   1209          /* FAT handling - Remove a cluster chain                                 */
   1210          /*-----------------------------------------------------------------------*/
   1211          #if !_FS_READONLY
   1212          static
   1213          FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
   1214          	_FDID* obj,			/* Corresponding object */
   1215          	DWORD clst,			/* Cluster to remove a chain from */
   1216          	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
   1217          )
   1218          {
   1219          	FRESULT res = FR_OK;
   1220          	DWORD nxt;
   1221          	FATFS *fs = obj->fs;
   1222          #if _FS_EXFAT || _USE_TRIM
   1223          	DWORD scl = clst, ecl = clst;
   1224          #endif
   1225          #if _USE_TRIM
   1226          	DWORD rt[2];
   1227          #endif
   1228          
   1229          	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
   1230          
   1231          	/* Mark the previous cluster 'EOC' on the FAT if it exists */
   1232          	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
   1233          		res = put_fat(fs, pclst, 0xFFFFFFFF);
   1234          		if (res != FR_OK) return res;
   1235          	}
   1236          
   1237          	/* Remove the chain */
   1238          	do {
   1239          		nxt = get_fat(obj, clst);			/* Get cluster status */
   1240          		if (nxt == 0) break;				/* Empty cluster? */
   1241          		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
   1242          		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
   1243          		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1244          			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
   1245          			if (res != FR_OK) return res;
   1246          		}
   1247          		if (fs->free_clst != 0xFFFFFFFF) {	/* Update FSINFO */
   1248          			fs->free_clst++;
   1249          			fs->fsi_flag |= 1;
   1250          		}
   1251          #if _FS_EXFAT || _USE_TRIM
   1252          		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
   1253          			ecl = nxt;
   1254          		} else {				/* End of contiguous cluster block */ 
   1255          #if _FS_EXFAT
   1256          			if (fs->fs_type == FS_EXFAT) {
   1257          				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
   1258          				if (res != FR_OK) return res;
   1259          			}
   1260          #endif
   1261          #if _USE_TRIM
   1262          			rt[0] = clust2sect(fs, scl);					/* Start sector */
   1263          			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
   1264          			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
   1265          #endif
   1266          			scl = ecl = nxt;
   1267          		}
   1268          #endif
   1269          		clst = nxt;					/* Next cluster */
   1270          	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
   1271          
   1272          #if _FS_EXFAT
   1273          	if (fs->fs_type == FS_EXFAT) {
   1274          		if (pclst == 0) {	/* Does object have no chain? */
   1275          			obj->stat = 0;		/* Change the object status 'initial' */
   1276          		} else {
   1277          			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
   1278          				obj->stat = 2;	/* Change the object status 'contiguous' */
   1279          			}
   1280          		}
   1281          	}
   1282          #endif
   1283          	return FR_OK;
   1284          }
   1285          #endif
   1286          
   1287          
   1288          
   1289          
   1290          /*-----------------------------------------------------------------------*/
   1291          /* FAT handling - Stretch a chain or Create a new chain                  */
   1292          /*-----------------------------------------------------------------------*/
   1293          #if !_FS_READONLY
   1294          static
   1295          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   1296          	_FDID* obj,			/* Corresponding object */
   1297          	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
   1298          )
   1299          {
   1300          	DWORD cs, ncl, scl;
   1301          	FRESULT res;
   1302          	FATFS *fs = obj->fs;
   1303          
   1304          
   1305          	if (clst == 0) {	/* Create a new chain */
   1306          		scl = fs->last_clst;				/* Get suggested cluster to start at */
   1307          		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
   1308          	}
   1309          	else {				/* Stretch current chain */
   1310          		cs = get_fat(obj, clst);			/* Check the cluster status */
   1311          		if (cs < 2) return 1;				/* Invalid value */
   1312          		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   1313          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   1314          		scl = clst;
   1315          	}
   1316          
   1317          #if _FS_EXFAT
   1318          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   1319          		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
   1320          		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
   1321          		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
   1322          		if (res == FR_INT_ERR) return 1;
   1323          		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
   1324          		if (clst == 0) {							/* Is it a new chain? */
   1325          			obj->stat = 2;							/* Set status 'contiguous chain' */
   1326          		} else {									/* This is a stretched chain */
   1327          			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
   1328          				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
   1329          				obj->stat = 3;						/* Change status 'just fragmented' */
   1330          			}
   1331          		}
   1332          	} else
   1333          #endif
   1334          	{	/* At the FAT12/16/32 */
   1335          		ncl = scl;	/* Start cluster */
   1336          		for (;;) {
   1337          			ncl++;							/* Next cluster */
   1338          			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
   1339          				ncl = 2;
   1340          				if (ncl > scl) return 0;	/* No free cluster */
   1341          			}
   1342          			cs = get_fat(obj, ncl);			/* Get the cluster status */
   1343          			if (cs == 0) break;				/* Found a free cluster */
   1344          			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
   1345          			if (ncl == scl) return 0;		/* No free cluster */
   1346          		}
   1347          	}
   1348          
   1349          	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
   1350          		res = FR_OK;						/* FAT does not need to be written */
   1351          	} else {
   1352          		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
   1353          		if (res == FR_OK && clst) {
   1354          			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
   1355          		}
   1356          	}
   1357          
   1358          	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
   1359          		fs->last_clst = ncl;
   1360          		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
   1361          		fs->fsi_flag |= 1;
   1362          	} else {
   1363          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
   1364          	}
   1365          
   1366          	return ncl;		/* Return new cluster number or error status */
   1367          }
   1368          #endif /* !_FS_READONLY */
   1369          
   1370          
   1371          
   1372          
   1373          /*-----------------------------------------------------------------------*/
   1374          /* FAT handling - Convert offset into cluster with link map table        */
   1375          /*-----------------------------------------------------------------------*/
   1376          
   1377          #if _USE_FASTSEEK
   1378          static
   1379          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1380          	FIL* fp,		/* Pointer to the file object */
   1381          	DWORD ofs		/* File offset to be converted to cluster# */
   1382          )
   1383          {
   1384          	DWORD cl, ncl, *tbl;
   1385          	FATFS *fs = fp->obj.fs;
   1386          
   1387          
   1388          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1389          	cl = ofs / SS(fs) / fs->csize;	/* Cluster order from top of the file */
   1390          	for (;;) {
   1391          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1392          		if (ncl == 0) return 0;	/* End of table? (error) */
   1393          		if (cl < ncl) break;	/* In this fragment? */
   1394          		cl -= ncl; tbl++;		/* Next fragment */
   1395          	}
   1396          	return cl + *tbl;	/* Return the cluster number */
   1397          }
   1398          #endif	/* _USE_FASTSEEK */
   1399          
   1400          
   1401          
   1402          /*-----------------------------------------------------------------------*/
   1403          /* Directory handling - Set directory index                              */
   1404          /*-----------------------------------------------------------------------*/
   1405          
   1406          static
   1407          FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
   1408          	DIR* dp,		/* Pointer to directory object */
   1409          	DWORD ofs		/* Offset of directory table */
   1410          )
   1411          {
   1412          	DWORD csz, clst;
   1413          	FATFS *fs = dp->obj.fs;
   1414          
   1415          
   1416          	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
   1417          		return FR_INT_ERR;
   1418          	}
   1419          	dp->dptr = ofs;				/* Set current offset */
   1420          	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
   1421          	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
   1422          		clst = fs->dirbase;
   1423          		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
   1424          	}
   1425          
   1426          	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   1427          		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
   1428          		dp->sect = fs->dirbase;
   1429          
   1430          	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
   1431          		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
   1432          		while (ofs >= csz) {				/* Follow cluster chain */
   1433          			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
   1434          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1435          			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
   1436          			ofs -= csz;
   1437          		}
   1438          		dp->sect = clust2sect(fs, clst);
   1439          	}
   1440          	dp->clust = clst;					/* Current cluster# */
   1441          	if (!dp->sect) return FR_INT_ERR;
   1442          	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
   1443          	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
   1444          
   1445          	return FR_OK;
   1446          }
   1447          
   1448          
   1449          
   1450          
   1451          /*-----------------------------------------------------------------------*/
   1452          /* Directory handling - Move directory table index next                  */
   1453          /*-----------------------------------------------------------------------*/
   1454          
   1455          static
   1456          FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1457          	DIR* dp,		/* Pointer to the directory object */
   1458          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1459          )
   1460          {
   1461          	DWORD ofs, clst;
   1462          	FATFS *fs = dp->obj.fs;
   1463          #if !_FS_READONLY
   1464          	UINT n;
   1465          #endif
   1466          
   1467          	ofs = dp->dptr + SZDIRE;	/* Next entry */
   1468          	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
   1469          
   1470          	if (ofs % SS(fs) == 0) {	/* Sector changed? */
   1471          		dp->sect++;				/* Next sector */
   1472          
   1473          		if (!dp->clust) {		/* Static table */
   1474          			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
   1475          				dp->sect = 0; return FR_NO_FILE;
   1476          			}
   1477          		}
   1478          		else {					/* Dynamic table */
   1479          			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
   1480          				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
   1481          				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
   1482          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
   1483          				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
   1484          #if !_FS_READONLY
   1485          					if (!stretch) {								/* If no stretch, report EOT */
   1486          						dp->sect = 0; return FR_NO_FILE;
   1487          					}
   1488          					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
   1489          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   1490          					if (clst == 1) return FR_INT_ERR;			/* Internal error */
   1491          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1492          					/* Clean-up the stretched table */
   1493          					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
   1494          					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
   1495          					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
   1496          					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
   1497          						fs->wflag = 1;
   1498          						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
   1499          					}
   1500          					fs->winsect -= n;							/* Restore window offset */
   1501          #else
   1502          					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
   1503          					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
   1504          #endif
   1505          				}
   1506          				dp->clust = clst;		/* Initialize data for new cluster */
   1507          				dp->sect = clust2sect(fs, clst);
   1508          			}
   1509          		}
   1510          	}
   1511          	dp->dptr = ofs;						/* Current entry */
   1512          	dp->dir = &fs->win[ofs % SS(fs)];	/* Pointer to the entry in the win[] */
   1513          
   1514          	return FR_OK;
   1515          }
   1516          
   1517          
   1518          
   1519          
   1520          /*-----------------------------------------------------------------------*/
   1521          /* Directory handling - Reserve a block of directory entries             */
   1522          /*-----------------------------------------------------------------------*/
   1523          
   1524          #if !_FS_READONLY
   1525          static
   1526          FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
   1527          	DIR* dp,		/* Pointer to the directory object */
   1528          	UINT nent		/* Number of contiguous entries to allocate */
   1529          )
   1530          {
   1531          	FRESULT res;
   1532          	UINT n;
   1533          	FATFS *fs = dp->obj.fs;
   1534          
   1535          
   1536          	res = dir_sdi(dp, 0);
   1537          	if (res == FR_OK) {
   1538          		n = 0;
   1539          		do {
   1540          			res = move_window(fs, dp->sect);
   1541          			if (res != FR_OK) break;
   1542          #if _FS_EXFAT
   1543          			if (fs->fs_type == FS_EXFAT ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
   1544          #else
   1545          			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
   1546          #endif
   1547          				if (++n == nent) break;	/* A block of contiguous free entries is found */
   1548          			} else {
   1549          				n = 0;					/* Not a blank entry. Restart to search */
   1550          			}
   1551          			res = dir_next(dp, 1);
   1552          		} while (res == FR_OK);	/* Next entry with table stretch enabled */
   1553          	}
   1554          
   1555          	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   1556          	return res;
   1557          }
   1558          #endif
   1559          
   1560          
   1561          
   1562          
   1563          /*-----------------------------------------------------------------------*/
   1564          /* FAT: Directory handling - Load/Store start cluster number             */
   1565          /*-----------------------------------------------------------------------*/
   1566          
   1567          static
   1568          DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
   1569          	FATFS* fs,		/* Pointer to the fs object */
   1570          	const BYTE* dir	/* Pointer to the key entry */
   1571          )
   1572          {
   1573          	DWORD cl;
   1574          
   1575          	cl = ld_word(dir + DIR_FstClusLO);
   1576          	if (fs->fs_type == FS_FAT32) {
   1577          		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
   1578          	}
   1579          
   1580          	return cl;
   1581          }
   1582          
   1583          
   1584          #if !_FS_READONLY
   1585          static
   1586          void st_clust (
   1587          	FATFS* fs,	/* Pointer to the fs object */
   1588          	BYTE* dir,	/* Pointer to the key entry */
   1589          	DWORD cl	/* Value to be set */
   1590          )
   1591          {
   1592          	st_word(dir + DIR_FstClusLO, (WORD)cl);
   1593          	if (fs->fs_type == FS_FAT32) {
   1594          		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
   1595          	}
   1596          }
   1597          #endif
   1598          
   1599          
   1600          
   1601          
   1602          /*------------------------------------------------------------------------*/
   1603          /* FAT-LFN: LFN handling                                                  */
   1604          /*------------------------------------------------------------------------*/
   1605          #if _USE_LFN != 0
   1606          static
   1607          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
   1608          
   1609          /*--------------------------------------------------------*/
   1610          /* FAT-LFN: Compare a part of file name with an LFN entry */
   1611          /*--------------------------------------------------------*/
   1612          static
   1613          int cmp_lfn (				/* 1:matched, 0:not matched */
   1614          	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
   1615          	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
   1616          )
   1617          {
   1618          	UINT i, s;
   1619          	WCHAR wc, uc;
   1620          
   1621          
   1622          	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1623          
   1624          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1625          
   1626          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1627          		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
   1628          		if (wc) {
   1629          			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
   1630          				return 0;					/* Not matched */
   1631          			}
   1632          			wc = uc;
   1633          		} else {
   1634          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1635          		}
   1636          	}
   1637          
   1638          	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
   1639          
   1640          	return 1;		/* The part of LFN matched */
   1641          }
   1642          
   1643          
   1644          
   1645          #if _FS_MINIMIZE <= 1 || _FS_EXFAT
   1646          /*-----------------------------------------------------*/
   1647          /* FAT-LFN: Pick a part of file name from an LFN entry */
   1648          /*-----------------------------------------------------*/
   1649          static
   1650          int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
   1651          	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
   1652          	BYTE* dir			/* Pointer to the LFN entry */
   1653          )
   1654          {
   1655          	UINT i, s;
   1656          	WCHAR wc, uc;
   1657          
   1658          
   1659          	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1660          
   1661          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1662          
   1663          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1664          		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
   1665          		if (wc) {
   1666          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1667          			lfnbuf[i++] = wc = uc;			/* Store it */
   1668          		} else {
   1669          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1670          		}
   1671          	}
   1672          
   1673          	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
   1674          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1675          		lfnbuf[i] = 0;
   1676          	}
   1677          
   1678          	return 1;		/* The part of LFN is valid */
   1679          }
   1680          #endif
   1681          
   1682          #if !_FS_READONLY
   1683          /*-----------------------------------------*/
   1684          /* FAT-LFN: Create an entry of LFN entries */
   1685          /*-----------------------------------------*/
   1686          static
   1687          void put_lfn (
   1688          	const WCHAR* lfn,	/* Pointer to the LFN */
   1689          	BYTE* dir,			/* Pointer to the LFN entry to be created */
   1690          	BYTE ord,			/* LFN order (1-20) */
   1691          	BYTE sum			/* Checksum of the corresponding SFN */
   1692          )
   1693          {
   1694          	UINT i, s;
   1695          	WCHAR wc;
   1696          
   1697          
   1698          	dir[LDIR_Chksum] = sum;			/* Set checksum */
   1699          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1700          	dir[LDIR_Type] = 0;
   1701          	st_word(dir + LDIR_FstClusLO, 0);
   1702          
   1703          	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
   1704          	s = wc = 0;
   1705          	do {
   1706          		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
   1707          		st_word(dir + LfnOfs[s], wc);		/* Put it */
   1708          		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
   1709          	} while (++s < 13);
   1710          	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
   1711          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1712          }
   1713          
   1714          #endif
   1715          #endif
   1716          
   1717          
   1718          
   1719          /*-----------------------------------------------------------------------*/
   1720          /* FAT-LFN: Create a Numbered SFN                                        */
   1721          /*-----------------------------------------------------------------------*/
   1722          #if _USE_LFN != 0 && !_FS_READONLY
   1723          static
   1724          void gen_numname (
   1725          	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
   1726          	const BYTE* src,	/* Pointer to SFN */
   1727          	const WCHAR* lfn,	/* Pointer to LFN */
   1728          	UINT seq			/* Sequence number */
   1729          )
   1730          {
   1731          	BYTE ns[8], c;
   1732          	UINT i, j;
   1733          	WCHAR wc;
   1734          	DWORD sr;
   1735          
   1736          
   1737          	mem_cpy(dst, src, 11);
   1738          
   1739          	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
   1740          		sr = seq;
   1741          		while (*lfn) {	/* Create a CRC */
   1742          			wc = *lfn++;
   1743          			for (i = 0; i < 16; i++) {
   1744          				sr = (sr << 1) + (wc & 1);
   1745          				wc >>= 1;
   1746          				if (sr & 0x10000) sr ^= 0x11021;
   1747          			}
   1748          		}
   1749          		seq = (UINT)sr;
   1750          	}
   1751          
   1752          	/* itoa (hexdecimal) */
   1753          	i = 7;
   1754          	do {
   1755          		c = (seq % 16) + '0';
   1756          		if (c > '9') c += 7;
   1757          		ns[i--] = c;
   1758          		seq /= 16;
   1759          	} while (seq);
   1760          	ns[i] = '~';
   1761          
   1762          	/* Append the number */
   1763          	for (j = 0; j < i && dst[j] != ' '; j++) {
   1764          		if (IsDBCS1(dst[j])) {
   1765          			if (j == i - 1) break;
   1766          			j++;
   1767          		}
   1768          	}
   1769          	do {
   1770          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1771          	} while (j < 8);
   1772          }
   1773          #endif
   1774          
   1775          
   1776          
   1777          /*-----------------------------------------------------------------------*/
   1778          /* FAT-LFN: Calculate checksum of an SFN entry                           */
   1779          /*-----------------------------------------------------------------------*/
   1780          #if _USE_LFN != 0
   1781          static
   1782          BYTE sum_sfn (
   1783          	const BYTE* dir		/* Pointer to the SFN entry */
   1784          )
   1785          {
   1786          	BYTE sum = 0;
   1787          	UINT n = 11;
   1788          
   1789          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1790          	return sum;
   1791          }
   1792          #endif
   1793          
   1794          
   1795          
   1796          
   1797          #if _FS_EXFAT
   1798          /*-----------------------------------------------------------------------*/
   1799          /* exFAT: Directory handling - Load/Store a block of directory entries   */
   1800          /*-----------------------------------------------------------------------*/
   1801          
   1802          static
   1803          WORD xdir_sum (			/* Get checksum of the directoly block */
   1804          	const BYTE* dir		/* Directory entry block to be calculated */
   1805          )
   1806          {
   1807          	UINT i, szblk;
   1808          	WORD sum;
   1809          
   1810          
   1811          	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
   1812          	for (i = sum = 0; i < szblk; i++) {
   1813          		if (i == XDIR_SetSum) {	/* Skip sum field */
   1814          			i++;
   1815          		} else {
   1816          			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
   1817          		}
   1818          	}
   1819          	return sum;
   1820          }
   1821          
   1822          
   1823          
   1824          static
   1825          WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
   1826          	const WCHAR* name	/* File name to be calculated */
   1827          )
   1828          {
   1829          	WCHAR chr;
   1830          	WORD sum = 0;
   1831          
   1832          
   1833          	while ((chr = *name++) != 0) {
   1834          		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
   1835          		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
   1836          		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
   1837          	}
   1838          	return sum;
   1839          }
   1840          
   1841          
   1842          /*------------------------------------------------------*/
   1843          /* exFAT: Get object information from a directory block */
   1844          /*------------------------------------------------------*/
   1845          static
   1846          void get_xdir_info (
   1847          	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
   1848          	FILINFO* fno		/* Buffer to store the extracted file information */
   1849          )
   1850          {
   1851          	UINT di, si, nc;
   1852          	WCHAR w;
   1853          
   1854          	/* Get file name */
   1855          #if _LFN_UNICODE
   1856          	if (dirb[XDIR_NumName] <= _MAX_LFN) {
   1857          		for (si = SZDIRE * 2, di = 0; di < dirb[XDIR_NumName]; si += 2, di++) {
   1858          			if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
   1859          			w = ld_word(dirb + si);				/* Get a character */
   1860          			fno->fname[di] = w;					/* Store it */
   1861          		}
   1862          	} else {
   1863          		di = 0;	/* Buffer overflow and inaccessible object */
   1864          	}
   1865          #else
   1866          	for (si = SZDIRE * 2, di = nc = 0; nc < dirb[XDIR_NumName]; si += 2, nc++) {
   1867          		if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
   1868          		w = ld_word(dirb + si);				/* Get a character */
   1869          		w = ff_convert(w, 0);				/* Unicode -> OEM */
   1870          		if (w == 0) { di = 0; break; }		/* Could not be converted and inaccessible object */
   1871          		if (_DF1S && w >= 0x100) {			/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
   1872          			fno->fname[di++] = (char)(w >> 8);
   1873          		}
   1874          		if (di >= _MAX_LFN) { di = 0; break; }	/* Buffer overflow and inaccessible object */
   1875          		fno->fname[di++] = (char)w;
   1876          	}
   1877          #endif
   1878          	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object? */
   1879          	fno->fname[di] = 0;						/* Terminate file name */
   1880          
   1881          	fno->altname[0] = 0;							/* No SFN */
   1882          	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
   1883          	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
   1884          	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
   1885          	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
   1886          }
   1887          
   1888          
   1889          /*-----------------------------------*/
   1890          /* exFAT: Get a directry entry block */
   1891          /*-----------------------------------*/
   1892          static
   1893          FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
   1894          	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
   1895          )
   1896          {
   1897          	FRESULT res;
   1898          	UINT i, nent;
   1899          	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
   1900          
   1901          
   1902          	/* Load 85 entry */
   1903          	res = move_window(dp->obj.fs, dp->sect);
   1904          	if (res != FR_OK) return res;
   1905          	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
   1906          	mem_cpy(&dirb[0], dp->dir, SZDIRE);
   1907          	nent = dirb[XDIR_NumSec] + 1;
   1908          
   1909          	/* Load C0 entry */
   1910          	res = dir_next(dp, 0);
   1911          	if (res != FR_OK) return res;
   1912          	res = move_window(dp->obj.fs, dp->sect);
   1913          	if (res != FR_OK) return res;
   1914          	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
   1915          	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
   1916          
   1917          	/* Load C1 entries */
   1918          	if (nent < 3 || nent > 19) return FR_NO_FILE;
   1919          	i = SZDIRE * 2; nent *= SZDIRE;
   1920          	do {
   1921          		res = dir_next(dp, 0);
   1922          		if (res != FR_OK) return res;
   1923          		res = move_window(dp->obj.fs, dp->sect);
   1924          		if (res != FR_OK) return res;
   1925          		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
   1926          		mem_cpy(dirb + i, dp->dir, SZDIRE);
   1927          		i += SZDIRE;
   1928          	} while (i < nent);
   1929          
   1930          	/* Sanity check */
   1931          	if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
   1932          
   1933          	return FR_OK;
   1934          }
   1935          
   1936          
   1937          #if !_FS_READONLY || _FS_RPATH != 0 
   1938          /*------------------------------------------------*/
   1939          /* exFAT: Load the object's directory entry block */
   1940          /*------------------------------------------------*/
   1941          static
   1942          FRESULT load_obj_dir (	
   1943          	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
   1944          	const _FDID* obj	/* Object with containing directory information */
   1945          )
   1946          {
   1947          	FRESULT res;
   1948          
   1949          
   1950          	/* Open object containing directory */
   1951          	dp->obj.fs = obj->fs;
   1952          	dp->obj.sclust = obj->c_scl;
   1953          	dp->obj.stat = (BYTE)obj->c_size;
   1954          	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
   1955          	dp->blk_ofs = obj->c_ofs;
   1956          
   1957          	res = dir_sdi(dp, dp->blk_ofs);	/* Goto the block location */
   1958          	if (res == FR_OK) {
   1959          		res = load_xdir(dp);		/* Load the object's entry block */
   1960          	}
   1961          	return res;
   1962          }
   1963          #endif
   1964          
   1965          
   1966          #if !_FS_READONLY
   1967          /*-----------------------------------------------*/
   1968          /* exFAT: Store the directory block to the media */
   1969          /*-----------------------------------------------*/
   1970          static
   1971          FRESULT store_xdir (
   1972          	DIR* dp				/* Pointer to the direcotry object */
   1973          )
   1974          {
   1975          	FRESULT res;
   1976          	UINT nent;
   1977          	WORD sum;
   1978          	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
   1979          
   1980          	/* Create set sum */
   1981          	sum = xdir_sum(dirb);
   1982          	st_word(dirb + XDIR_SetSum, sum);
   1983          	nent = dirb[XDIR_NumSec] + 1;
   1984          
   1985          	res = dir_sdi(dp, dp->blk_ofs);
   1986          	while (res == FR_OK && (res = move_window(dp->obj.fs, dp->sect)) == FR_OK) {
   1987          		mem_cpy(dp->dir, dirb, SZDIRE);
   1988          		dp->obj.fs->wflag = 1;
   1989          		if (--nent == 0) break;
   1990          		dirb += SZDIRE;
   1991          		res = dir_next(dp, 0);
   1992          	}
   1993          	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
   1994          }
   1995          
   1996          
   1997          /*-------------------------------------------*/
   1998          /* exFAT: Create a new directory enrty block */
   1999          /*-------------------------------------------*/
   2000          static
   2001          void create_xdir (
   2002          	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
   2003          	const WCHAR* lfn	/* Pointer to the nul terminated file name */
   2004          )
   2005          {
   2006          	UINT i;
   2007          	BYTE nb, nc;
   2008          	WCHAR chr;
   2009          	WORD hash;
   2010          
   2011          
   2012          	mem_set(dirb, 0, 2 * SZDIRE);			/* Initialize 85+C0 entry */
   2013          	dirb[XDIR_Type] = 0x85;
   2014          	dirb[XDIR_Type + SZDIRE] = 0xC0;
   2015          	hash = xname_sum(lfn);
   2016          	st_word(dirb + XDIR_NameHash, hash);	/* Set name hash */
   2017          
   2018          	i = SZDIRE * 2;	/* C1 offset */
   2019          	nc = 0; nb = 1; chr = 1;
   2020          	do {
   2021          		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
   2022          		do {	/* Fill name field */
   2023          			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
   2024          			st_word(dirb + i, chr); i += 2;	/* Store it */
   2025          		} while (i % SZDIRE);
   2026          		nb++;
   2027          	} while (lfn[nc]);	/* Fill next entry if any char follows */
   2028          
   2029          	dirb[XDIR_NumName] = nc;	/* Set name length */
   2030          	dirb[XDIR_NumSec] = nb;		/* Set number of C0+C1s */
   2031          }
   2032          #endif
   2033          #endif
   2034          
   2035          
   2036          
   2037          /*-----------------------------------------------------------------------*/
   2038          /* Read an object from the directory                                     */
   2039          /*-----------------------------------------------------------------------*/
   2040          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
   2041          static
   2042          FRESULT dir_read (
   2043          	DIR* dp,		/* Pointer to the directory object */
   2044          	int vol			/* Filtered by 0:file/directory or 1:volume label */
   2045          )
   2046          {
   2047          	FRESULT res = FR_NO_FILE;
   2048          	FATFS *fs = dp->obj.fs;
   2049          	BYTE a, c;
   2050          #if _USE_LFN != 0
   2051          	BYTE ord = 0xFF, sum = 0xFF;
   2052          #endif
   2053          
   2054          	while (dp->sect) {
   2055          		res = move_window(fs, dp->sect);
   2056          		if (res != FR_OK) break;
   2057          		c = dp->dir[DIR_Name];	/* Test for the entry type */
   2058          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
   2059          #if _FS_EXFAT
   2060          		if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2061          			if (_USE_LABEL && vol) {
   2062          				if (c == 0x83) break;	/* Volume label entry? */
   2063          			} else {
   2064          				if (c == 0x85) {		/* Start of the entry block? */
   2065          					dp->blk_ofs = dp->dptr;	/* Set location of block */
   2066          					res = load_xdir(dp);	/* Load the entry block */
   2067          					if (res == FR_OK) {
   2068          						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
   2069          					}
   2070          					break;
   2071          				}
   2072          			}
   2073          		} else
   2074          #endif
   2075          		{	/* At the FAT12/16/32 */
   2076          			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
   2077          #if _USE_LFN != 0	/* LFN configuration */
   2078          			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   2079          				ord = 0xFF;
   2080          			} else {
   2081          				if (a == AM_LFN) {			/* An LFN entry is found */
   2082          					if (c & LLEF) {			/* Is it start of an LFN sequence? */
   2083          						sum = dp->dir[LDIR_Chksum];
   2084          						c &= ~LLEF; ord = c;
   2085          						dp->blk_ofs = dp->dptr;
   2086          					}
   2087          					/* Check LFN validity and capture it */
   2088          					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
   2089          				} else {					/* An SFN entry is found */
   2090          					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
   2091          						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
   2092          					}
   2093          					break;
   2094          				}
   2095          			}
   2096          #else		/* Non LFN configuration */
   2097          			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
   2098          				break;
   2099          			}
   2100          #endif
   2101          		}
   2102          		res = dir_next(dp, 0);		/* Next entry */
   2103          		if (res != FR_OK) break;
   2104          	}
   2105          
   2106          	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
   2107          	return res;
   2108          }
   2109          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   2110          
   2111          
   2112          
   2113          /*-----------------------------------------------------------------------*/
   2114          /* Directory handling - Find an object in the directory                  */
   2115          /*-----------------------------------------------------------------------*/
   2116          
   2117          static
   2118          FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
   2119          	DIR* dp			/* Pointer to the directory object with the file name */
   2120          )
   2121          {
   2122          	FRESULT res;
   2123          	FATFS *fs = dp->obj.fs;
   2124          	BYTE c;
   2125          #if _USE_LFN != 0
   2126          	BYTE a, ord, sum;
   2127          #endif
   2128          
   2129          	res = dir_sdi(dp, 0);			/* Rewind directory object */
   2130          	if (res != FR_OK) return res;
   2131          #if _FS_EXFAT
   2132          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2133          		BYTE nc;
   2134          		UINT di, ni;
   2135          		WORD hash = xname_sum(dp->lfn);		/* Hash value of the name to find */
   2136          
   2137          		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
   2138          			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
   2139          			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
   2140          				if ((di % SZDIRE) == 0) di += 2;
   2141          				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(dp->lfn[ni])) break;
   2142          			}
   2143          			if (nc == 0 && !dp->lfn[ni]) break;	/* Name matched? */
   2144          		}
   2145          		return res;
   2146          	}
   2147          #endif
   2148          	/* At the FAT12/16/32 */
   2149          #if _USE_LFN != 0
   2150          	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2151          #endif
   2152          	do {
   2153          		res = move_window(fs, dp->sect);
   2154          		if (res != FR_OK) break;
   2155          		c = dp->dir[DIR_Name];
   2156          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   2157          #if _USE_LFN != 0	/* LFN configuration */
   2158          		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
   2159          		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   2160          			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2161          		} else {
   2162          			if (a == AM_LFN) {			/* An LFN entry is found */
   2163          				if (dp->lfn) {
   2164          					if (c & LLEF) {		/* Is it start of LFN sequence? */
   2165          						sum = dp->dir[LDIR_Chksum];
   2166          						c &= ~LLEF; ord = c;	/* LFN start order */
   2167          						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
   2168          					}
   2169          					/* Check validity of the LFN entry and compare it with given name */
   2170          					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
   2171          				}
   2172          			} else {					/* An SFN entry is found */
   2173          				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
   2174          				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
   2175          				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2176          			}
   2177          		}
   2178          #else		/* Non LFN configuration */
   2179          		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
   2180          		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
   2181          #endif
   2182          		res = dir_next(dp, 0);	/* Next entry */
   2183          	} while (res == FR_OK);
   2184          
   2185          	return res;
   2186          }
   2187          
   2188          
   2189          
   2190          
   2191          /*-----------------------------------------------------------------------*/
   2192          /* Register an object to the directory                                   */
   2193          /*-----------------------------------------------------------------------*/
   2194          #if !_FS_READONLY
   2195          static
   2196          FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
   2197          	DIR* dp				/* Target directory with object name to be created */
   2198          )
   2199          {
   2200          	FRESULT res;
   2201          	FATFS *fs = dp->obj.fs;
   2202          #if _USE_LFN != 0	/* LFN configuration */
   2203          	UINT n, nlen, nent;
   2204          	BYTE sn[12], *fn, sum;
   2205          	WCHAR *lfn;
   2206          
   2207          
   2208          	fn = dp->fn; lfn = dp->lfn;
   2209          	if (fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
   2210          	for (nlen = 0; lfn[nlen]; nlen++) ;	/* Get lfn length */
   2211          
   2212          #if _FS_EXFAT
   2213          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2214          		DIR dj;
   2215          
   2216          		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
   2217          		res = dir_alloc(dp, nent);		/* Allocate entries */
   2218          		if (res != FR_OK) return res;
   2219          		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
   2220          
   2221          		if (dp->obj.stat & 4) {			/* Has the sub-directory been stretched? */
   2222          			dp->obj.stat &= 3;
   2223          			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
   2224          			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
   2225          			if (res != FR_OK) return res;
   2226          			res = load_obj_dir(&dj, &dp->obj);
   2227          			if (res != FR_OK) return res;	/* Load the object status */
   2228          			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
   2229          			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
   2230          			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
   2231          			res = store_xdir(&dj);			/* Store the object status */
   2232          			if (res != FR_OK) return res;
   2233          		}
   2234          
   2235          		create_xdir(fs->dirbuf, lfn);	/* Create on-memory directory block to be written later */
   2236          		return FR_OK;
   2237          	}
   2238          #endif
   2239          	/* At the FAT12/16/32 */
   2240          	mem_cpy(sn, fn, 12);
   2241          	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   2242          		fn[NSFLAG] = 0; dp->lfn = 0;		/* Find only SFN */
   2243          		for (n = 1; n < 100; n++) {
   2244          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   2245          			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   2246          			if (res != FR_OK) break;
   2247          		}
   2248          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   2249          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   2250          		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   2251          	}
   2252          
   2253          	/* Create an SFN with/without LFNs. */
   2254          	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
   2255          	res = dir_alloc(dp, nent);		/* Allocate entries */
   2256          	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   2257          		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
   2258          		if (res == FR_OK) {
   2259          			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
   2260          			do {					/* Store LFN entries in bottom first */
   2261          				res = move_window(fs, dp->sect);
   2262          				if (res != FR_OK) break;
   2263          				put_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   2264          				fs->wflag = 1;
   2265          				res = dir_next(dp, 0);	/* Next entry */
   2266          			} while (res == FR_OK && --nent);
   2267          		}
   2268          	}
   2269          
   2270          #else	/* Non LFN configuration */
   2271          	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
   2272          
   2273          #endif
   2274          
   2275          	/* Set SFN entry */
   2276          	if (res == FR_OK) {
   2277          		res = move_window(fs, dp->sect);
   2278          		if (res == FR_OK) {
   2279          			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
   2280          			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
   2281          #if _USE_LFN != 0
   2282          			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   2283          #endif
   2284          			fs->wflag = 1;
   2285          		}
   2286          	}
   2287          
   2288          	return res;
   2289          }
   2290          #endif /* !_FS_READONLY */
   2291          
   2292          
   2293          
   2294          
   2295          /*-----------------------------------------------------------------------*/
   2296          /* Remove an object from the directory                                   */
   2297          /*-----------------------------------------------------------------------*/
   2298          #if !_FS_READONLY && !_FS_MINIMIZE
   2299          static
   2300          FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
   2301          	DIR* dp				/* Directory object pointing the entry to be removed */
   2302          )
   2303          {
   2304          	FRESULT res;
   2305          	FATFS *fs = dp->obj.fs;
   2306          #if _USE_LFN != 0	/* LFN configuration */
   2307          	DWORD last = dp->dptr;
   2308          
   2309          	res = dp->blk_ofs == 0xFFFFFFFF ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
   2310          	if (res == FR_OK) {
   2311          		do {
   2312          			res = move_window(fs, dp->sect);
   2313          			if (res != FR_OK) break;
   2314          			/* Mark an entry 'deleted' */
   2315          			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2316          				dp->dir[XDIR_Type] &= 0x7F;
   2317          			} else {									/* At the FAT12/16/32 */
   2318          				dp->dir[DIR_Name] = DDEM;
   2319          			}
   2320          			fs->wflag = 1;
   2321          			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
   2322          			res = dir_next(dp, 0);	/* Next entry */
   2323          		} while (res == FR_OK);
   2324          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   2325          	}
   2326          #else			/* Non LFN configuration */
   2327          
   2328          	res = move_window(fs, dp->sect);
   2329          	if (res == FR_OK) {
   2330          		dp->dir[DIR_Name] = DDEM;
   2331          		fs->wflag = 1;
   2332          	}
   2333          #endif
   2334          
   2335          	return res;
   2336          }
   2337          #endif /* !_FS_READONLY */
   2338          
   2339          
   2340          
   2341          
   2342          /*-----------------------------------------------------------------------*/
   2343          /* Get file information from directory entry                             */
   2344          /*-----------------------------------------------------------------------*/
   2345          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
   2346          static
   2347          void get_fileinfo (		/* No return code */
   2348          	DIR* dp,			/* Pointer to the directory object */
   2349          	FILINFO* fno	 	/* Pointer to the file information to be filled */
   2350          )
   2351          {
   2352          	UINT i, j;
   2353          	TCHAR c;
   2354          #if _USE_LFN != 0
   2355          	WCHAR w, *lfn;
   2356          	WCHAR lfv;
   2357          #endif
   2358          
   2359          
   2360          	fno->fname[0] = 0;		/* Invaidate file info */
   2361          	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
   2362          
   2363          #if _USE_LFN != 0	/* LFN configuration */
   2364          #if _FS_EXFAT
   2365          	if (dp->obj.fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2366          		get_xdir_info(dp->obj.fs->dirbuf, fno);
   2367          		return;
   2368          	} else
   2369          #endif
   2370          	{	/* At the FAT12/16/32 */
   2371          		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
   2372          			i = 0; lfn = dp->lfn;
   2373          			while ((w = *lfn++) != 0) {		/* Get an LFN character */
   2374          #if !_LFN_UNICODE
   2375          				w = ff_convert(w, 0);		/* Unicode -> OEM */
   2376          				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
   2377          				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
   2378          					fno->fname[i++] = (char)(w >> 8);
   2379          				}
   2380          #endif
   2381          				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
   2382          				fno->fname[i++] = (char)w;
   2383          			}
   2384          			fno->fname[i] = 0;	/* Terminate the LFN */
   2385          		}
   2386          	}
   2387          
   2388          	i = j = 0;
   2389          	lfv = fno->fname[i];	/* LFN is exist if non-zero */
   2390          	while (i < 11) {		/* Copy name body and extension */
   2391          		c = (TCHAR)dp->dir[i++];
   2392          		if (c == ' ') continue;				/* Skip padding spaces */
   2393          		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   2394          		if (i == 9) {						/* Insert a . if extension is exist */
   2395          			if (!lfv) fno->fname[j] = '.';
   2396          			fno->altname[j++] = '.';
   2397          		}
   2398          #if _LFN_UNICODE
   2399          		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
   2400          			c = c << 8 | dp->dir[i++];
   2401          		}
   2402          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   2403          		if (!c) c = '?';
   2404          #endif
   2405          		fno->altname[j] = c;
   2406          		if (!lfv) {
   2407          			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
   2408          				c += 0x20;			/* To lower */
   2409          			}
   2410          			fno->fname[j] = c;
   2411          		}
   2412          		j++;
   2413          	}
   2414          	if (!lfv) {
   2415          		fno->fname[j] = 0;
   2416          		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
   2417          	}
   2418          	fno->altname[j] = 0;	/* Terminate the SFN */
   2419          
   2420          #else	/* Non-LFN configuration */
   2421          	i = j = 0;
   2422          	while (i < 11) {		/* Copy name body and extension */
   2423          		c = (TCHAR)dp->dir[i++];
   2424          		if (c == ' ') continue;				/* Skip padding spaces */
   2425          		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   2426          		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
   2427          		fno->fname[j++] = c;
   2428          	}
   2429          	fno->fname[j] = 0;
   2430          #endif
   2431          
   2432          	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
   2433          	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
   2434          	fno->fdate = ld_word(dp->dir + DIR_WrtDate);	/* Date */
   2435          	fno->ftime = ld_word(dp->dir + DIR_WrtTime);	/* Time */
   2436          }
   2437          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
   2438          
   2439          
   2440          
   2441          
   2442          /*-----------------------------------------------------------------------*/
   2443          /* Pattern matching                                                      */
   2444          /*-----------------------------------------------------------------------*/
   2445          #if _USE_FIND && _FS_MINIMIZE <= 1
   2446          static
   2447          WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
   2448          	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
   2449          )
   2450          {
   2451          #if !_LFN_UNICODE
   2452          	WCHAR chr;
   2453          
   2454          	chr = (BYTE)*(*ptr)++;					/* Get a byte */
   2455          	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
   2456          #ifdef _EXCVT
   2457          	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
   2458          #else
   2459          	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
   2460          		chr = chr << 8 | (BYTE)*(*ptr)++;
   2461          	}
   2462          #endif
   2463          	return chr;
   2464          #else
   2465          	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
   2466          #endif
   2467          }
   2468          
   2469          
   2470          static
   2471          int pattern_matching (	/* 0:not matched, 1:matched */
   2472          	const TCHAR* pat,	/* Matching pattern */
   2473          	const TCHAR* nam,	/* String to be tested */
   2474          	int skip,			/* Number of pre-skip chars (number of ?s) */
   2475          	int inf				/* Infinite search (* specified) */
   2476          )
   2477          {
   2478          	const TCHAR *pp, *np;
   2479          	WCHAR pc, nc;
   2480          	int nm, nx;
   2481          
   2482          
   2483          	while (skip--) {				/* Pre-skip name chars */
   2484          		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
   2485          	}
   2486          	if (!*pat && inf) return 1;		/* (short circuit) */
   2487          
   2488          	do {
   2489          		pp = pat; np = nam;			/* Top of pattern and name to match */
   2490          		for (;;) {
   2491          			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
   2492          				nm = nx = 0;
   2493          				do {				/* Analyze the wildcard chars */
   2494          					if (*pp++ == '?') nm++; else nx = 1;
   2495          				} while (*pp == '?' || *pp == '*');
   2496          				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recursions upto number of wildcard blocks in the pattern) */
   2497          				nc = *np; break;	/* Branch mismatched */
   2498          			}
   2499          			pc = get_achar(&pp);	/* Get a pattern char */
   2500          			nc = get_achar(&np);	/* Get a name char */
   2501          			if (pc != nc) break;	/* Branch mismatched? */
   2502          			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
   2503          		}
   2504          		get_achar(&nam);			/* nam++ */
   2505          	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
   2506          
   2507          	return 0;
   2508          }
   2509          #endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
   2510          
   2511          
   2512          
   2513          
   2514          /*-----------------------------------------------------------------------*/
   2515          /* Pick a top segment and create the object name in directory form       */
   2516          /*-----------------------------------------------------------------------*/
   2517          
   2518          static
   2519          FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
   2520          	DIR* dp,			/* Pointer to the directory object */
   2521          	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
   2522          )
   2523          {
   2524          #if _USE_LFN != 0	/* LFN configuration */
   2525          	BYTE b, cf;
   2526          	WCHAR w, *lfn;
   2527          	UINT i, ni, si, di;
   2528          	const TCHAR *p;
   2529          
   2530          	/* Create LFN in Unicode */
   2531          	p = *path; lfn = dp->lfn; si = di = 0;
   2532          	for (;;) {
   2533          		w = p[si++];					/* Get a character */
   2534          		if (w < ' ' || w == '/' || w == '\\') {		/* Break on end of segment */
   2535          			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
   2536          			break;
   2537          		}
   2538          		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
   2539          #if !_LFN_UNICODE
   2540          		w &= 0xFF;
   2541          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   2542          			b = (BYTE)p[si++];			/* Get 2nd byte */
   2543          			w = (w << 8) + b;			/* Create a DBC */
   2544          			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
   2545          		}
   2546          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   2547          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   2548          #endif
   2549          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
   2550          		lfn[di++] = w;					/* Store the Unicode character */
   2551          	}
   2552          	*path = &p[si];						/* Return pointer to the next segment */
   2553          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2554          #if _FS_RPATH != 0
   2555          	if ((di == 1 && lfn[di - 1] == '.') ||
   2556          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
   2557          		lfn[di] = 0;
   2558          		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
   2559          			dp->fn[i] = (i < di) ? '.' : ' ';
   2560          		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   2561          		return FR_OK;
   2562          	}
   2563          #endif
   2564          	while (di) {						/* Snip off trailing spaces and dots if exist */
   2565          		w = lfn[di - 1];
   2566          		if (w != ' ' && w != '.') break;
   2567          		di--;
   2568          	}
   2569          	lfn[di] = 0;						/* LFN is created */
   2570          	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
   2571          
   2572          	/* Create SFN in directory form */
   2573          	mem_set(dp->fn, ' ', 11);
   2574          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   2575          	if (si) cf |= NS_LOSS | NS_LFN;
   2576          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   2577          
   2578          	b = i = 0; ni = 8;
   2579          	for (;;) {
   2580          		w = lfn[si++];					/* Get an LFN character */
   2581          		if (!w) break;					/* Break on end of the LFN */
   2582          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   2583          			cf |= NS_LOSS | NS_LFN; continue;
   2584          		}
   2585          
   2586          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   2587          			if (ni == 11) {				/* Long extension */
   2588          				cf |= NS_LOSS | NS_LFN; break;
   2589          			}
   2590          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   2591          			if (si > di) break;			/* No extension */
   2592          			si = di; i = 8; ni = 11;	/* Enter extension section */
   2593          			b <<= 2; continue;
   2594          		}
   2595          
   2596          		if (w >= 0x80) {				/* Non ASCII character */
   2597          #ifdef _EXCVT
   2598          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   2599          			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   2600          #else
   2601          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   2602          #endif
   2603          			cf |= NS_LFN;				/* Force create LFN entry */
   2604          		}
   2605          
   2606          		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
   2607          			if (i >= ni - 1) {
   2608          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   2609          			}
   2610          			dp->fn[i++] = (BYTE)(w >> 8);
   2611          		} else {						/* SBC */
   2612          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   2613          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   2614          			} else {
   2615          				if (IsUpper(w)) {		/* ASCII large capital */
   2616          					b |= 2;
   2617          				} else {
   2618          					if (IsLower(w)) {	/* ASCII small capital */
   2619          						b |= 1; w -= 0x20;
   2620          					}
   2621          				}
   2622          			}
   2623          		}
   2624          		dp->fn[i++] = (BYTE)w;
   2625          	}
   2626          
   2627          	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
   2628          
   2629          	if (ni == 8) b <<= 2;
   2630          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
   2631          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   2632          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   2633          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   2634          	}
   2635          
   2636          	dp->fn[NSFLAG] = cf;	/* SFN is created */
   2637          
   2638          	return FR_OK;
   2639          
   2640          
   2641          #else	/* Non-LFN configuration */
   2642          	BYTE b, c, d, *sfn;
   2643          	UINT ni, si, i;
   2644          	const char *p;
   2645          
   2646          	/* Create file name in directory form */
   2647          	p = *path; sfn = dp->fn;
   2648          	mem_set(sfn, ' ', 11);
   2649          	si = i = b = 0; ni = 8;
   2650          #if _FS_RPATH != 0
   2651          	if (p[si] == '.') { /* Is this a dot entry? */
   2652          		for (;;) {
   2653          			c = (BYTE)p[si++];
   2654          			if (c != '.' || si >= 3) break;
   2655          			sfn[i++] = c;
   2656          		}
   2657          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   2658          		*path = &p[si];									/* Return pointer to the next segment */
   2659          		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   2660          		return FR_OK;
   2661          	}
   2662          #endif
   2663          	for (;;) {
   2664          		c = (BYTE)p[si++];
   2665          		if (c <= ' ' || c == '/' || c == '\\') {	/* Break on end of segment */
   2666          			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
   2667          			break;
   2668          		}
   2669          		if (c == '.' || i >= ni) {
   2670          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   2671          			i = 8; ni = 11;
   2672          			b <<= 2; continue;
   2673          		}
   2674          		if (c >= 0x80) {				/* Extended character? */
   2675          			b |= 3;						/* Eliminate NT flag */
   2676          #ifdef _EXCVT
   2677          			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
   2678          #else
   2679          #if !_DF1S
   2680          			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
   2681          #endif
   2682          #endif
   2683          		}
   2684          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
   2685          			d = (BYTE)p[si++];			/* Get 2nd byte */
   2686          			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
   2687          			sfn[i++] = c;
   2688          			sfn[i++] = d;
   2689          		} else {						/* SBC */
   2690          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
   2691          			if (IsUpper(c)) {			/* ASCII large capital? */
   2692          				b |= 2;
   2693          			} else {
   2694          				if (IsLower(c)) {		/* ASCII small capital? */
   2695          					b |= 1; c -= 0x20;
   2696          				}
   2697          			}
   2698          			sfn[i++] = c;
   2699          		}
   2700          	}
   2701          	*path = &p[si];						/* Return pointer to the next segment */
   2702          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2703          
   2704          	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
   2705          	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
   2706          
   2707          	if (ni == 8) b <<= 2;
   2708          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   2709          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   2710          
   2711          	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
   2712          
   2713          	return FR_OK;
   2714          #endif
   2715          }
   2716          
   2717          
   2718          
   2719          
   2720          /*-----------------------------------------------------------------------*/
   2721          /* Follow a file path                                                    */
   2722          /*-----------------------------------------------------------------------*/
   2723          
   2724          static
   2725          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   2726          	DIR* dp,			/* Directory object to return last directory and found object */
   2727          	const TCHAR* path	/* Full-path string to find a file or directory */
   2728          )
   2729          {
   2730          	FRESULT res;
   2731          	BYTE ns;
   2732          	_FDID *obj = &dp->obj;
   2733          	FATFS *fs = obj->fs;
   2734          
   2735          
   2736          #if _FS_RPATH != 0
   2737          	if (*path != '/' && *path != '\\') {	/* Without heading separator */
   2738          		obj->sclust = fs->cdir;				/* Start from the current directory */
   2739          	} else
   2740          #endif
   2741          	{										/* With heading separator */
   2742          		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
   2743          		obj->sclust = 0;					/* Start from the root directory */
   2744          	}
   2745          #if _FS_EXFAT && _FS_RPATH != 0
   2746          	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
   2747          		DIR dj;
   2748          
   2749          		obj->c_scl = fs->cdc_scl;
   2750          		obj->c_size = fs->cdc_size;
   2751          		obj->c_ofs = fs->cdc_ofs;
   2752          		res = load_obj_dir(&dj, obj);
   2753          		if (res != FR_OK) return res;
   2754          		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
   2755          		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   2756          	}
   2757          #endif
   2758          
   2759          	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   2760          		dp->fn[NSFLAG] = NS_NONAME;
   2761          		res = dir_sdi(dp, 0);
   2762          
   2763          	} else {								/* Follow path */
   2764          		for (;;) {
   2765          			res = create_name(dp, &path);	/* Get a segment name of the path */
   2766          			if (res != FR_OK) break;
   2767          			res = dir_find(dp);				/* Find an object with the segment name */
   2768          			ns = dp->fn[NSFLAG];
   2769          			if (res != FR_OK) {				/* Failed to find the object */
   2770          				if (res == FR_NO_FILE) {	/* Object is not found */
   2771          					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
   2772          						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   2773          						dp->fn[NSFLAG] = NS_NONAME;
   2774          						res = FR_OK;
   2775          					} else {							/* Could not find the object */
   2776          						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   2777          					}
   2778          				}
   2779          				break;
   2780          			}
   2781          			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   2782          			/* Get into the sub-directory */
   2783          			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
   2784          				res = FR_NO_PATH; break;
   2785          			}
   2786          #if _FS_EXFAT
   2787          			if (fs->fs_type == FS_EXFAT) {
   2788          				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
   2789          				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
   2790          				obj->c_ofs = dp->blk_ofs;
   2791          				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
   2792          				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   2793          				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   2794          			} else
   2795          #endif
   2796          			{
   2797          				obj->sclust = ld_clust(fs, &fs->win[dp->dptr % SS(fs)]);	/* Open next directory */
   2798          			}
   2799          		}
   2800          	}
   2801          
   2802          	return res;
   2803          }
   2804          
   2805          
   2806          
   2807          
   2808          /*-----------------------------------------------------------------------*/
   2809          /* Get logical drive number from path name                               */
   2810          /*-----------------------------------------------------------------------*/
   2811          
   2812          static
   2813          int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
   2814          	const TCHAR** path	/* Pointer to pointer to the path name */
   2815          )
   2816          {
   2817          	const TCHAR *tp, *tt;
   2818          	UINT i;
   2819          	int vol = -1;
   2820          #if _STR_VOLUME_ID		/* Find string drive id */
   2821          	static const char* const str[] = {_VOLUME_STRS};
   2822          	const char *sp;
   2823          	char c;
   2824          	TCHAR tc;
   2825          #endif
   2826          
   2827          
   2828          	if (*path) {	/* If the pointer is not a null */
   2829          		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   2830          		if (*tt == ':') {	/* If a ':' is exist in the path name */
   2831          			tp = *path;
   2832          			i = *tp++ - '0'; 
   2833          			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   2834          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2835          					vol = (int)i;
   2836          					*path = ++tt;
   2837          				}
   2838          			}
   2839          #if _STR_VOLUME_ID
   2840          			 else {	/* No numeric drive number, find string drive id */
   2841          				i = 0; tt++;
   2842          				do {
   2843          					sp = str[i]; tp = *path;
   2844          					do {	/* Compare a string drive id with path name */
   2845          						c = *sp++; tc = *tp++;
   2846          						if (IsLower(tc)) tc -= 0x20;
   2847          					} while (c && (TCHAR)c == tc);
   2848          				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
   2849          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2850          					vol = (int)i;
   2851          					*path = tt;
   2852          				}
   2853          			}
   2854          #endif
   2855          			return vol;
   2856          		}
   2857          #if _FS_RPATH != 0 && _VOLUMES >= 2
   2858          		vol = CurrVol;	/* Current drive */
   2859          #else
   2860          		vol = 0;		/* Drive 0 */
   2861          #endif
   2862          	}
   2863          	return vol;
   2864          }
   2865          
   2866          
   2867          
   2868          
   2869          /*-----------------------------------------------------------------------*/
   2870          /* Load a sector and check if it is an FAT boot sector                   */
   2871          /*-----------------------------------------------------------------------*/
   2872          
   2873          static
   2874          BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
   2875          	FATFS* fs,	/* File system object */
   2876          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2877          )
   2878          {
   2879          	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
   2880          	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
   2881          
   2882          	if (ld_word(&fs->win[BS_55AA]) != 0xAA55) return 3;	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   2883          
   2884          	if ((ld_dword(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
   2885          	if ((ld_dword(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
   2886          #if _FS_EXFAT
   2887          	if (!mem_cmp(&fs->win[BS_OEMName], "EXFAT   ", 8)) return 1;
   2888          #endif
   2889          	return 2;
   2890          }
   2891          
   2892          
   2893          
   2894          
   2895          /*-----------------------------------------------------------------------*/
   2896          /* Find logical drive and check if the volume is mounted                 */
   2897          /*-----------------------------------------------------------------------*/
   2898          
   2899          static
   2900          FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
   2901          	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
   2902          	FATFS** rfs,		/* Pointer to pointer to the found file system object */
   2903          	BYTE mode			/* !=0: Check write protection for write access */
   2904          )
   2905          {
   2906          	BYTE fmt, *pt;
   2907          	int vol;
   2908          	DSTATUS stat;
   2909          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
   2910          	WORD nrsv;
   2911          	FATFS *fs;
   2912          	UINT i;
   2913          
   2914          
   2915          	/* Get logical drive number from the path name */
   2916          	*rfs = 0;
   2917          	vol = get_ldnumber(path);
   2918          	if (vol < 0) return FR_INVALID_DRIVE;
   2919          
   2920          	/* Check if the file system object is valid or not */
   2921          	fs = FatFs[vol];					/* Get pointer to the file system object */
   2922          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   2923          
   2924          	ENTER_FF(fs);						/* Lock the volume */
   2925          	*rfs = fs;							/* Return pointer to the file system object */
   2926          
   2927          	mode &= ~FA_READ;					/* Desired access mode, write access or not */
   2928          	if (fs->fs_type) {					/* If the volume has been mounted */
   2929          		stat = disk_status(fs->drv);
   2930          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   2931          			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
   2932          				return FR_WRITE_PROTECTED;
   2933          			}
   2934          			return FR_OK;				/* The file system object is valid */
   2935          		}
   2936          	}
   2937          
   2938          	/* The file system object is not valid. */
   2939          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2940          
   2941          	fs->fs_type = 0;					/* Clear the file system object */
   2942          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   2943          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   2944          	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
   2945          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   2946          	}
   2947          	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
   2948          		return FR_WRITE_PROTECTED;
   2949          	}
   2950          #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
   2951          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2952          		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
   2953          #endif
   2954          	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
   2955          	bsect = 0;
   2956          	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT boot sector as SFD */
   2957          	if (fmt == 2 || (fmt < 2 && LD2PT(vol))) {	/* Not an FAT boot sector or forced partition number */
   2958          		for (i = 0; i < 4; i++) {			/* Get partition offset */
   2959          			pt = fs->win + MBR_Table + i * SZ_PTE;
   2960          			br[i] = pt[4] ? ld_dword(&pt[8]) : 0;
   2961          		}
   2962          		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   2963          		if (i) i--;
   2964          		do {								/* Find an FAT volume */
   2965          			bsect = br[i];
   2966          			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
   2967          		} while (!LD2PT(vol) && fmt >= 2 && ++i < 4);
   2968          	}
   2969          	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   2970          	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
   2971          
   2972          	/* An FAT volume is found. Following code initializes the file system object */
   2973          
   2974          #if _FS_EXFAT
   2975          	if (fmt == 1) {
   2976          		QWORD maxlba;
   2977          
   2978          		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && !fs->win[i]; i++) ;	/* Check zero filler */
   2979          		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
   2980          
   2981          		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
   2982          
   2983          		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
   2984          			return FR_NO_FILESYSTEM;
   2985          
   2986          		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Number of sectors on the volume */
   2987          		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
   2988          
   2989          		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
   2990          
   2991          		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
   2992          		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Must be 1) */
   2993          
   2994          		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
   2995          		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
   2996          
   2997          		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
   2998          		fs->n_fatent = nclst + 2;
   2999          		if (fs->n_fatent >= 0x80000000) return FR_NO_FILESYSTEM;	/* (Must be <= 0x7FFFFFFF) */
   3000          
   3001          		/* Boundaries and Limits */
   3002          		fs->volbase = bsect;
   3003          		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
   3004          		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
   3005          		if (maxlba < fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
   3006          		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
   3007          
   3008          		/* Check if bitmap location is in assumption (at the first cluster) */
   3009          		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
   3010          		for (i = 0; i < SS(fs); i += SZDIRE) {
   3011          			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
   3012          		}
   3013          		if (i == SS(fs)) return FR_NO_FILESYSTEM;
   3014          #if !_FS_READONLY
   3015          		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
   3016          #endif
   3017          #if _USE_LFN == 1
   3018          		fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
   3019          #endif
   3020          		fmt = FS_EXFAT;			/* FAT sub-type */
   3021          	} else
   3022          #endif
   3023          	{
   3024          		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
   3025          
   3026          		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
   3027          		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
   3028          		fs->fsize = fasize;
   3029          
   3030          		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
   3031          		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
   3032          		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   3033          
   3034          		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
   3035          		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   3036          
   3037          		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   3038          		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
   3039          
   3040          		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
   3041          		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
   3042          
   3043          		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
   3044          		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
   3045          
   3046          		/* Determine the FAT sub type */
   3047          		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
   3048          		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   3049          		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   3050          		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
   3051          		fmt = FS_FAT12;
   3052          		if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   3053          		if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   3054          
   3055          		/* Boundaries and Limits */
   3056          		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   3057          		fs->volbase = bsect;								/* Volume start sector */
   3058          		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   3059          		fs->database = bsect + sysect;						/* Data start sector */
   3060          		if (fmt == FS_FAT32) {
   3061          			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
   3062          			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   3063          			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
   3064          			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   3065          		} else {
   3066          			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
   3067          			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   3068          			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   3069          				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   3070          		}
   3071          		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
   3072          
   3073          #if !_FS_READONLY
   3074          		/* Initialize cluster allocation information */
   3075          		fs->last_clst = fs->free_clst = 0xFFFFFFFF;
   3076          
   3077          		/* Get FSINFO if available */
   3078          		fs->fsi_flag = 0x80;
   3079          #if (_FS_NOFSINFO & 3) != 3
   3080          		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
   3081          			&& ld_word(fs->win + BPB_FSInfo32) == 1
   3082          			&& move_window(fs, bsect + 1) == FR_OK)
   3083          		{
   3084          			fs->fsi_flag = 0;
   3085          			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   3086          				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
   3087          				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
   3088          			{
   3089          #if (_FS_NOFSINFO & 1) == 0
   3090          				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
   3091          #endif
   3092          #if (_FS_NOFSINFO & 2) == 0
   3093          				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
   3094          #endif
   3095          			}
   3096          		}
   3097          #endif
   3098          #endif
   3099          	}
   3100          
   3101          	fs->fs_type = fmt;	/* FAT sub-type */
   3102          	fs->id = ++Fsid;	/* File system mount ID */
   3103          #if _FS_RPATH != 0
   3104          	fs->cdir = 0;		/* Initialize current directory */
   3105          #endif
   3106          #if _FS_LOCK != 0		/* Clear file lock semaphores */
   3107          	clear_lock(fs);
   3108          #endif
   3109          	return FR_OK;
   3110          }
   3111          
   3112          
   3113          
   3114          
   3115          /*-----------------------------------------------------------------------*/
   3116          /* Check if the file/directory object is valid or not                    */
   3117          /*-----------------------------------------------------------------------*/
   3118          
   3119          static
   3120          FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
   3121          	void* dfp,		/* Pointer to the FIL/DIR object to check validity */
   3122          	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
   3123          )
   3124          {
   3125          	_FDID *obj = (_FDID*)dfp;	/* Assuming .obj in the FIL/DIR is the first member */
   3126          	FRESULT res;
   3127          
   3128          
   3129          	if (!dfp || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
   3130          		*fs = 0;				/* The object is invalid */
   3131          		res = FR_INVALID_OBJECT;
   3132          	} else {
   3133          		*fs = obj->fs;			/* Owner file sytem object */
   3134          		ENTER_FF(obj->fs);		/* Lock file system */
   3135          		res = FR_OK;
   3136          	}
   3137          	return res;
   3138          }
   3139          
   3140          
   3141          
   3142          
   3143          /*---------------------------------------------------------------------------
   3144          
   3145             Public Functions (FatFs API)
   3146          
   3147          ----------------------------------------------------------------------------*/
   3148          
   3149          
   3150          
   3151          /*-----------------------------------------------------------------------*/
   3152          /* Mount/Unmount a Logical Drive                                         */
   3153          /*-----------------------------------------------------------------------*/
   3154          
   3155          FRESULT f_mount (
   3156          	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
   3157          	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
   3158          	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
   3159          )
   3160          {
   3161          	FATFS *cfs;
   3162          	int vol;
   3163          	FRESULT res;
   3164          	const TCHAR *rp = path;
   3165          
   3166          
   3167          	vol = get_ldnumber(&rp);
   3168          	if (vol < 0) return FR_INVALID_DRIVE;
   3169          	cfs = FatFs[vol];					/* Pointer to fs object */
   3170          
   3171          	if (cfs) {
   3172          #if _FS_LOCK != 0
   3173          		clear_lock(cfs);
   3174          #endif
   3175          #if _FS_REENTRANT						/* Discard sync object of the current volume */
   3176          		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
   3177          #endif
   3178          		cfs->fs_type = 0;				/* Clear old fs object */
   3179          	}
   3180          
   3181          	if (fs) {
   3182          		fs->fs_type = 0;				/* Clear new fs object */
   3183          #if _FS_REENTRANT						/* Create sync object for the new volume */
   3184          		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   3185          #endif
   3186          	}
   3187          	FatFs[vol] = fs;					/* Register new fs object */
   3188          
   3189          	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   3190          
   3191          	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
   3192          	LEAVE_FF(fs, res);
   3193          }
   3194          
   3195          
   3196          
   3197          
   3198          /*-----------------------------------------------------------------------*/
   3199          /* Open or Create a File                                                 */
   3200          /*-----------------------------------------------------------------------*/
   3201          
   3202          FRESULT f_open (
   3203          	FIL* fp,			/* Pointer to the blank file object */
   3204          	const TCHAR* path,	/* Pointer to the file name */
   3205          	BYTE mode			/* Access mode and file open mode flags */
   3206          )
   3207          {
   3208          	FRESULT res;
   3209          	DIR dj;
   3210          	FATFS *fs;
   3211          #if !_FS_READONLY
   3212          	DWORD dw, cl;
   3213          #endif
   3214          	DEF_NAMBUF;
   3215          
   3216          
   3217          	if (!fp) return FR_INVALID_OBJECT;
   3218          	fp->obj.fs = 0;		/* Clear file object */
   3219          
   3220          	/* Get logical drive number */
   3221          	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   3222          	res = find_volume(&path, &fs, mode);
   3223          	if (res == FR_OK) {
   3224          		dj.obj.fs = fs;
   3225          		INIT_NAMBUF(dj);
   3226          		res = follow_path(&dj, path);	/* Follow the file path */
   3227          #if !_FS_READONLY	/* R/W configuration */
   3228          		if (res == FR_OK) {
   3229          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
   3230          				res = FR_INVALID_NAME;
   3231          			}
   3232          #if _FS_LOCK != 0
   3233          			else {
   3234          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3235          			}
   3236          #endif
   3237          		}
   3238          		/* Create or Open a file */
   3239          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   3240          			if (res != FR_OK) {					/* No file, create new */
   3241          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   3242          #if _FS_LOCK != 0
   3243          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   3244          #else
   3245          					res = dir_register(&dj);
   3246          #endif
   3247          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   3248          			}
   3249          			else {								/* Any object is already existing */
   3250          				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   3251          					res = FR_DENIED;
   3252          				} else {
   3253          					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
   3254          				}
   3255          			}
   3256          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   3257          				dw = GET_FATTIME();
   3258          #if _FS_EXFAT
   3259          				if (fs->fs_type == FS_EXFAT) {
   3260          					/* Get current allocation info */
   3261          					fp->obj.fs = fs;
   3262          					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
   3263          					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   3264          					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   3265          					/* Initialize directory entry block */
   3266          					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
   3267          					fs->dirbuf[XDIR_CrtTime10] = 0;
   3268          					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
   3269          					fs->dirbuf[XDIR_ModTime10] = 0;
   3270          					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
   3271          					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
   3272          					st_qword(fs->dirbuf + XDIR_FileSize, 0);
   3273          					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
   3274          					fs->dirbuf[XDIR_GenFlags] = 1;
   3275          					res = store_xdir(&dj);
   3276          					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
   3277          						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
   3278          						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
   3279          					}
   3280          				} else
   3281          #endif
   3282          				{
   3283          					/* Clean directory info */
   3284          					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
   3285          					st_dword(dj.dir + DIR_WrtTime, dw);	/* Set modified time */
   3286          					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
   3287          					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
   3288          					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
   3289          					st_dword(dj.dir + DIR_FileSize, 0);
   3290          					fs->wflag = 1;
   3291          
   3292          					if (cl) {							/* Remove the cluster chain if exist */
   3293          						dw = fs->winsect;
   3294          						res = remove_chain(&dj.obj, cl, 0);
   3295          						if (res == FR_OK) {
   3296          							res = move_window(fs, dw);
   3297          							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
   3298          						}
   3299          					}
   3300          				}
   3301          			}
   3302          		}
   3303          		else {	/* Open an existing file */
   3304          			if (res == FR_OK) {					/* Following succeeded */
   3305          				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
   3306          					res = FR_NO_FILE;
   3307          				} else {
   3308          					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
   3309          						res = FR_DENIED;
   3310          					}
   3311          				}
   3312          			}
   3313          		}
   3314          		if (res == FR_OK) {
   3315          			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   3316          				mode |= _FA_MODIFIED;
   3317          			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
   3318          			fp->dir_ptr = dj.dir;
   3319          #if _FS_LOCK != 0
   3320          			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3321          			if (!fp->obj.lockid) res = FR_INT_ERR;
   3322          #endif
   3323          		}
   3324          #else		/* R/O configuration */
   3325          		if (res == FR_OK) {
   3326          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
   3327          				res = FR_INVALID_NAME;
   3328          			} else {
   3329          				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
   3330          					res = FR_NO_FILE;
   3331          				}
   3332          			}
   3333          		}
   3334          #endif
   3335          
   3336          		if (res == FR_OK) {
   3337          #if _FS_EXFAT
   3338          			if (fs->fs_type == FS_EXFAT) {
   3339          				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
   3340          				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   3341          				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   3342          				fp->obj.c_scl = dj.obj.sclust;
   3343          				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
   3344          				fp->obj.c_ofs = dj.blk_ofs;
   3345          			} else
   3346          #endif
   3347          			{
   3348          				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
   3349          				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
   3350          			}
   3351          #if _USE_FASTSEEK
   3352          			fp->cltbl = 0;			/* Normal seek mode */
   3353          #endif
   3354          			fp->err = 0;			/* Clear error flag */
   3355          			fp->fptr = 0;			/* Set file pointer */
   3356          			fp->sect = 0;			/* Invalidate current data sector */
   3357          			fp->flag = mode;		/* File access mode */
   3358          			fp->obj.fs = fs;	 	/* Validate the file object */
   3359          			fp->obj.id = fs->id;
   3360          		}
   3361          
   3362          		FREE_NAMBUF();
   3363          	}
   3364          
   3365          	LEAVE_FF(dj.obj.fs, res);
   3366          }
   3367          
   3368          
   3369          
   3370          
   3371          /*-----------------------------------------------------------------------*/
   3372          /* Read File                                                             */
   3373          /*-----------------------------------------------------------------------*/
   3374          
   3375          FRESULT f_read (
   3376          	FIL* fp, 	/* Pointer to the file object */
   3377          	void* buff,	/* Pointer to data buffer */
   3378          	UINT btr,	/* Number of bytes to read */
   3379          	UINT* br	/* Pointer to number of bytes read */
   3380          )
   3381          {
   3382          	FRESULT res;
   3383          	FATFS *fs;
   3384          	DWORD clst, sect;
   3385          	FSIZE_t remain;
   3386          	UINT rcnt, cc, csect;
   3387          	BYTE *rbuff = (BYTE*)buff;
   3388          
   3389          
   3390          	*br = 0;	/* Clear read byte counter */
   3391          	res = validate(fp, &fs);
   3392          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3393          	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
   3394          	remain = fp->obj.objsize - fp->fptr;
   3395          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   3396          
   3397          	for ( ;  btr;								/* Repeat until all data read */
   3398          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   3399          		if ((fp->fptr % SS(fs)) == 0) {			/* On the sector boundary? */
   3400          			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
   3401          			if (csect == 0) {					/* On the cluster boundary? */
   3402          				if (fp->fptr == 0) {			/* On the top of the file? */
   3403          					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
   3404          				} else {						/* Middle or end of the file */
   3405          #if _USE_FASTSEEK
   3406          					if (fp->cltbl) {
   3407          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3408          					} else
   3409          #endif
   3410          					{
   3411          						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
   3412          					}
   3413          				}
   3414          				if (clst < 2) ABORT(fs, FR_INT_ERR);
   3415          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3416          				fp->clust = clst;				/* Update current cluster */
   3417          			}
   3418          			sect = clust2sect(fs, fp->clust);	/* Get current sector */
   3419          			if (!sect) ABORT(fs, FR_INT_ERR);
   3420          			sect += csect;
   3421          			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
   3422          			if (cc) {							/* Read maximum contiguous sectors directly */
   3423          				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
   3424          					cc = fs->csize - csect;
   3425          				}
   3426          				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) {
   3427          					ABORT(fs, FR_DISK_ERR);
   3428          				}
   3429          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   3430          #if _FS_TINY
   3431          				if (fs->wflag && fs->winsect - sect < cc) {
   3432          					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
   3433          				}
   3434          #else
   3435          				if ((fp->flag & _FA_DIRTY) && fp->sect - sect < cc) {
   3436          					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
   3437          				}
   3438          #endif
   3439          #endif
   3440          				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
   3441          				continue;
   3442          			}
   3443          #if !_FS_TINY
   3444          			if (fp->sect != sect) {			/* Load data sector if not in cache */
   3445          #if !_FS_READONLY
   3446          				if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
   3447          					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3448          						ABORT(fs, FR_DISK_ERR);
   3449          					}
   3450          					fp->flag &= ~_FA_DIRTY;
   3451          				}
   3452          #endif
   3453          				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	{	/* Fill sector cache */
   3454          					ABORT(fs, FR_DISK_ERR);
   3455          				}
   3456          			}
   3457          #endif
   3458          			fp->sect = sect;
   3459          		}
   3460          		rcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Get partial sector data from sector buffer */
   3461          		if (rcnt > btr) rcnt = btr;
   3462          #if _FS_TINY
   3463          		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
   3464          			ABORT(fs, FR_DISK_ERR);
   3465          		}
   3466          		mem_cpy(rbuff, &fs->win[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
   3467          #else
   3468          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
   3469          #endif
   3470          	}
   3471          
   3472          	LEAVE_FF(fs, FR_OK);
   3473          }
   3474          
   3475          
   3476          
   3477          
   3478          #if !_FS_READONLY
   3479          /*-----------------------------------------------------------------------*/
   3480          /* Write File                                                            */
   3481          /*-----------------------------------------------------------------------*/
   3482          
   3483          FRESULT f_write (
   3484          	FIL* fp,			/* Pointer to the file object */
   3485          	const void* buff,	/* Pointer to the data to be written */
   3486          	UINT btw,			/* Number of bytes to write */
   3487          	UINT* bw			/* Pointer to number of bytes written */
   3488          )
   3489          {
   3490          	FRESULT res;
   3491          	FATFS *fs;
   3492          	DWORD clst, sect;
   3493          	UINT wcnt, cc, csect;
   3494          	const BYTE *wbuff = (const BYTE*)buff;
   3495          
   3496          
   3497          	*bw = 0;	/* Clear write byte counter */
   3498          	res = validate(fp, &fs);
   3499          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3500          	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   3501          
   3502          	/* Check fptr wrap-around (file size cannot exceed the limit on each FAT specs) */
   3503          	if ((_FS_EXFAT && fs->fs_type == FS_EXFAT && fp->fptr + btw < fp->fptr)
   3504          		|| (DWORD)fp->fptr + btw < (DWORD)fp->fptr) {
   3505          		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
   3506          	}
   3507          
   3508          	for ( ;  btw;							/* Repeat until all data written */
   3509          		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
   3510          		if ((fp->fptr % SS(fs)) == 0) {		/* On the sector boundary? */
   3511          			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
   3512          			if (csect == 0) {				/* On the cluster boundary? */
   3513          				if (fp->fptr == 0) {		/* On the top of the file? */
   3514          					clst = fp->obj.sclust;	/* Follow from the origin */
   3515          					if (clst == 0) {		/* If no cluster is allocated, */
   3516          						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
   3517          					}
   3518          				} else {					/* On the middle or end of the file */
   3519          #if _USE_FASTSEEK
   3520          					if (fp->cltbl) {
   3521          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3522          					} else
   3523          #endif
   3524          					{
   3525          						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   3526          					}
   3527          				}
   3528          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   3529          				if (clst == 1) ABORT(fs, FR_INT_ERR);
   3530          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3531          				fp->clust = clst;			/* Update current cluster */
   3532          				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
   3533          			}
   3534          #if _FS_TINY
   3535          			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK)	{	/* Write-back sector cache */
   3536          				ABORT(fs, FR_DISK_ERR);
   3537          			}
   3538          #else
   3539          			if (fp->flag & _FA_DIRTY) {		/* Write-back sector cache */
   3540          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3541          					ABORT(fs, FR_DISK_ERR);
   3542          				}
   3543          				fp->flag &= ~_FA_DIRTY;
   3544          			}
   3545          #endif
   3546          			sect = clust2sect(fs, fp->clust);	/* Get current sector */
   3547          			if (!sect) ABORT(fs, FR_INT_ERR);
   3548          			sect += csect;
   3549          			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
   3550          			if (cc) {						/* Write maximum contiguous sectors directly */
   3551          				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
   3552          					cc = fs->csize - csect;
   3553          				}
   3554          				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) {
   3555          					ABORT(fs, FR_DISK_ERR);
   3556          				}
   3557          #if _FS_MINIMIZE <= 2
   3558          #if _FS_TINY
   3559          				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   3560          					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
   3561          					fs->wflag = 0;
   3562          				}
   3563          #else
   3564          				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   3565          					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
   3566          					fp->flag &= ~_FA_DIRTY;
   3567          				}
   3568          #endif
   3569          #endif
   3570          				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
   3571          				continue;
   3572          			}
   3573          #if _FS_TINY
   3574          			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling at growing edge */
   3575          				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
   3576          				fs->winsect = sect;
   3577          			}
   3578          #else
   3579          			if (fp->sect != sect) {		/* Fill sector cache with file data */
   3580          				if (fp->fptr < fp->obj.objsize &&
   3581          					disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
   3582          						ABORT(fs, FR_DISK_ERR);
   3583          				}
   3584          			}
   3585          #endif
   3586          			fp->sect = sect;
   3587          		}
   3588          		wcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Put partial sector into file I/O buffer */
   3589          		if (wcnt > btw) wcnt = btw;
   3590          #if _FS_TINY
   3591          		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
   3592          			ABORT(fs, FR_DISK_ERR);
   3593          		}
   3594          		mem_cpy(&fs->win[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
   3595          		fs->wflag = 1;
   3596          #else
   3597          		mem_cpy(&fp->buf[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
   3598          		fp->flag |= _FA_DIRTY;
   3599          #endif
   3600          	}
   3601          
   3602          	fp->flag |= _FA_MODIFIED;						/* Set file change flag */
   3603          
   3604          	LEAVE_FF(fs, FR_OK);
   3605          }
   3606          
   3607          
   3608          
   3609          
   3610          /*-----------------------------------------------------------------------*/
   3611          /* Synchronize the File                                                  */
   3612          /*-----------------------------------------------------------------------*/
   3613          
   3614          FRESULT f_sync (
   3615          	FIL* fp		/* Pointer to the file object */
   3616          )
   3617          {
   3618          	FRESULT res;
   3619          	FATFS *fs;
   3620          	DWORD tm;
   3621          	BYTE *dir;
   3622          	DEF_DIRBUF;
   3623          
   3624          
   3625          	res = validate(fp, &fs);	/* Check validity of the object */
   3626          	if (res == FR_OK) {
   3627          		if (fp->flag & _FA_MODIFIED) {	/* Is there any change to the file? */
   3628          #if !_FS_TINY
   3629          			if (fp->flag & _FA_DIRTY) {	/* Write-back cached data if needed */
   3630          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3631          					LEAVE_FF(fs, FR_DISK_ERR);
   3632          				}
   3633          				fp->flag &= ~_FA_DIRTY;
   3634          			}
   3635          #endif
   3636          			/* Update the directory entry */
   3637          			tm = GET_FATTIME();				/* Modified time */
   3638          #if _FS_EXFAT
   3639          			if (fs->fs_type == FS_EXFAT) {
   3640          				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
   3641          				if (res == FR_OK) {
   3642          					DIR dj;
   3643          
   3644          					INIT_DIRBUF(fs);
   3645          					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
   3646          					if (res == FR_OK) {
   3647          						fs->dirbuf[XDIR_Attr] |= AM_ARC;					/* Set archive bit */
   3648          						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;		/* Update file allocation info */
   3649          						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
   3650          						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
   3651          						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
   3652          						st_dword(fs->dirbuf + XDIR_ModTime, tm);			/* Update modified time */
   3653          						fs->dirbuf[XDIR_ModTime10] = 0;
   3654          						st_dword(fs->dirbuf + XDIR_AccTime, 0);
   3655          						res = store_xdir(&dj);	/* Restore it to the directory */
   3656          						if (res == FR_OK) {
   3657          							res = sync_fs(fs);
   3658          							fp->flag &= ~_FA_MODIFIED;
   3659          						}
   3660          					}
   3661          					FREE_DIRBUF();
   3662          				}
   3663          			} else
   3664          #endif
   3665          			{
   3666          				res = move_window(fs, fp->dir_sect);
   3667          				if (res == FR_OK) {
   3668          					dir = fp->dir_ptr;
   3669          					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
   3670          					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
   3671          					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
   3672          					st_dword(dir + DIR_WrtTime, tm);				/* Update modified time */
   3673          					st_word(dir + DIR_LstAccDate, 0);
   3674          					fs->wflag = 1;
   3675          					res = sync_fs(fs);					/* Restore it to the directory */
   3676          					fp->flag &= ~_FA_MODIFIED;
   3677          				}
   3678          			}
   3679          		}
   3680          	}
   3681          
   3682          	LEAVE_FF(fs, res);
   3683          }
   3684          
   3685          #endif /* !_FS_READONLY */
   3686          
   3687          
   3688          
   3689          
   3690          /*-----------------------------------------------------------------------*/
   3691          /* Close File                                                            */
   3692          /*-----------------------------------------------------------------------*/
   3693          
   3694          FRESULT f_close (
   3695          	FIL* fp		/* Pointer to the file object to be closed */
   3696          )
   3697          {
   3698          	FRESULT res;
   3699          	FATFS *fs;
   3700          
   3701          #if !_FS_READONLY
   3702          	res = f_sync(fp);					/* Flush cached data */
   3703          	if (res == FR_OK)
   3704          #endif
   3705          	{
   3706          		res = validate(fp, &fs);	/* Lock volume */
   3707          		if (res == FR_OK) {
   3708          #if _FS_LOCK != 0
   3709          			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
   3710          			if (res == FR_OK)
   3711          #endif
   3712          			{
   3713          				fp->obj.fs = 0;			/* Invalidate file object */
   3714          			}
   3715          #if _FS_REENTRANT
   3716          			unlock_fs(fs, FR_OK);		/* Unlock volume */
   3717          #endif
   3718          		}
   3719          	}
   3720          	return res;
   3721          }
   3722          
   3723          
   3724          
   3725          
   3726          /*-----------------------------------------------------------------------*/
   3727          /* Change Current Directory or Current Drive, Get Current Directory      */
   3728          /*-----------------------------------------------------------------------*/
   3729          
   3730          #if _FS_RPATH >= 1
   3731          #if _VOLUMES >= 2
   3732          FRESULT f_chdrive (
   3733          	const TCHAR* path		/* Drive number */
   3734          )
   3735          {
   3736          	int vol;
   3737          
   3738          
   3739          	vol = get_ldnumber(&path);
   3740          	if (vol < 0) return FR_INVALID_DRIVE;
   3741          
   3742          	CurrVol = (BYTE)vol;
   3743          
   3744          	return FR_OK;
   3745          }
   3746          #endif
   3747          
   3748          
   3749          FRESULT f_chdir (
   3750          	const TCHAR* path	/* Pointer to the directory path */
   3751          )
   3752          {
   3753          	FRESULT res;
   3754          	DIR dj;
   3755          	FATFS *fs;
   3756          	DEF_NAMBUF;
   3757          
   3758          	/* Get logical drive number */
   3759          	res = find_volume(&path, &fs, 0);
   3760          	if (res == FR_OK) {
   3761          		dj.obj.fs = fs;
   3762          		INIT_NAMBUF(dj);
   3763          		res = follow_path(&dj, path);		/* Follow the path */
   3764          		if (res == FR_OK) {					/* Follow completed */
   3765          			if (dj.fn[NSFLAG] & NS_NONAME) {
   3766          				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
   3767          #if _FS_EXFAT
   3768          				if (fs->fs_type == FS_EXFAT) {
   3769          					fs->cdc_scl = dj.obj.c_scl;
   3770          					fs->cdc_size = dj.obj.c_size;
   3771          					fs->cdc_ofs = dj.obj.c_ofs;
   3772          				}
   3773          #endif
   3774          			} else {
   3775          				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
   3776          #if _FS_EXFAT
   3777          					if (fs->fs_type == FS_EXFAT) {
   3778          						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
   3779          						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
   3780          						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
   3781          						fs->cdc_ofs = dj.blk_ofs;
   3782          					} else
   3783          #endif
   3784          					{
   3785          						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
   3786          					}
   3787          				} else {
   3788          					res = FR_NO_PATH;		/* Reached but a file */
   3789          				}
   3790          			}
   3791          		}
   3792          		FREE_NAMBUF();
   3793          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   3794          	}
   3795          
   3796          	LEAVE_FF(fs, res);
   3797          }
   3798          
   3799          
   3800          #if _FS_RPATH >= 2
   3801          FRESULT f_getcwd (
   3802          	TCHAR* buff,	/* Pointer to the directory path */
   3803          	UINT len		/* Size of path */
   3804          )
   3805          {
   3806          	FRESULT res;
   3807          	DIR dj;
   3808          	FATFS *fs;
   3809          	UINT i, n;
   3810          	DWORD ccl;
   3811          	TCHAR *tp;
   3812          	FILINFO fno;
   3813          	DEF_NAMBUF;
   3814          
   3815          
   3816          	*buff = 0;
   3817          	/* Get logical drive number */
   3818          	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
   3819          	if (res == FR_OK) {
   3820          		dj.obj.fs = fs;
   3821          		INIT_NAMBUF(dj);
   3822          		i = len;			/* Bottom of buffer (directory stack base) */
   3823          		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
   3824          			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
   3825          			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
   3826          				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
   3827          				if (res != FR_OK) break;
   3828          				res = move_window(fs, dj.sect);
   3829          				if (res != FR_OK) break;
   3830          				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
   3831          				res = dir_sdi(&dj, 0);
   3832          				if (res != FR_OK) break;
   3833          				do {							/* Find the entry links to the child directory */
   3834          					res = dir_read(&dj, 0);
   3835          					if (res != FR_OK) break;
   3836          					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
   3837          					res = dir_next(&dj, 0);
   3838          				} while (res == FR_OK);
   3839          				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   3840          				if (res != FR_OK) break;
   3841          				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
   3842          				for (n = 0; fno.fname[n]; n++) ;
   3843          				if (i < n + 3) {
   3844          					res = FR_NOT_ENOUGH_CORE; break;
   3845          				}
   3846          				while (n) buff[--i] = fno.fname[--n];
   3847          				buff[--i] = '/';
   3848          			}
   3849          		}
   3850          		tp = buff;
   3851          		if (res == FR_OK) {
   3852          #if _VOLUMES >= 2
   3853          			*tp++ = '0' + CurrVol;			/* Put drive number */
   3854          			*tp++ = ':';
   3855          #endif
   3856          			if (i == len) {					/* Root-directory */
   3857          				*tp++ = '/';
   3858          			} else {						/* Sub-directroy */
   3859          				do		/* Add stacked path str */
   3860          					*tp++ = buff[i++];
   3861          				while (i < len);
   3862          			}
   3863          		}
   3864          		*tp = 0;
   3865          		FREE_NAMBUF();
   3866          	}
   3867          
   3868          	LEAVE_FF(fs, res);
   3869          }
   3870          #endif /* _FS_RPATH >= 2 */
   3871          #endif /* _FS_RPATH >= 1 */
   3872          
   3873          
   3874          
   3875          #if _FS_MINIMIZE <= 2
   3876          /*-----------------------------------------------------------------------*/
   3877          /* Seek File R/W Pointer                                                 */
   3878          /*-----------------------------------------------------------------------*/
   3879          
   3880          FRESULT f_lseek (
   3881          	FIL* fp,		/* Pointer to the file object */
   3882          	FSIZE_t ofs		/* File pointer from top of file */
   3883          )
   3884          {
   3885          	FRESULT res;
   3886          	FATFS *fs;
   3887          	DWORD clst, bcs, nsect;
   3888          	FSIZE_t ifptr;
   3889          #if _USE_FASTSEEK
   3890          	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   3891          #endif
   3892          
   3893          	res = validate(fp, &fs);		/* Check validity of the object */
   3894          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3895          #if _USE_FASTSEEK
   3896          	if (fp->cltbl) {	/* Fast seek */
   3897          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3898          			tbl = fp->cltbl;
   3899          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3900          			cl = fp->sclust;			/* Top of the chain */
   3901          			if (cl) {
   3902          				do {
   3903          					/* Get a fragment */
   3904          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3905          					do {
   3906          						pcl = cl; ncl++;
   3907          						cl = get_fat(fs, cl);
   3908          						if (cl <= 1) ABORT(fs, FR_INT_ERR);
   3909          						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3910          					} while (cl == pcl + 1);
   3911          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3912          						*tbl++ = ncl; *tbl++ = tcl;
   3913          					}
   3914          				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
   3915          			}
   3916          			*fp->cltbl = ulen;	/* Number of items used */
   3917          			if (ulen <= tlen) {
   3918          				*tbl = 0;		/* Terminate table */
   3919          			} else {
   3920          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3921          			}
   3922          		} else {						/* Fast seek */
   3923          			if (ofs > fp->fsize) {		/* Clip offset at the file size */
   3924          				ofs = fp->fsize;
   3925          			}
   3926          			fp->fptr = ofs;				/* Set file pointer */
   3927          			if (ofs) {
   3928          				fp->clust = clmt_clust(fp, ofs - 1);
   3929          				dsc = clust2sect(fs, fp->clust);
   3930          				if (!dsc) ABORT(fs, FR_INT_ERR);
   3931          				dsc += (ofs - 1) / SS(fs) & (fs->csize - 1);
   3932          				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
   3933          #if !_FS_TINY
   3934          #if !_FS_READONLY
   3935          					if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
   3936          						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3937          							ABORT(fp, FR_DISK_ERR);
   3938          						}
   3939          						fp->flag &= ~_FA_DIRTY;
   3940          					}
   3941          #endif
   3942          					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) {	/* Load current sector */
   3943          						ABORT(fs, FR_DISK_ERR);
   3944          					}
   3945          #endif
   3946          					fp->sect = dsc;
   3947          				}
   3948          			}
   3949          		}
   3950          	} else
   3951          #endif
   3952          
   3953          	/* Normal Seek */
   3954          	{
   3955          		if (ofs > fp->obj.objsize				/* In read-only mode, clip offset with the file size */
   3956          #if !_FS_READONLY
   3957          			 && !(fp->flag & FA_WRITE)
   3958          #endif
   3959          			) ofs = fp->obj.objsize;
   3960          
   3961          		ifptr = fp->fptr;
   3962          		fp->fptr = nsect = 0;
   3963          		if (ofs) {
   3964          			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
   3965          			if (ifptr > 0 &&
   3966          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   3967          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   3968          				ofs -= fp->fptr;
   3969          				clst = fp->clust;
   3970          			} else {									/* When seek to back cluster, */
   3971          				clst = fp->obj.sclust;					/* start from the first cluster */
   3972          #if !_FS_READONLY
   3973          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   3974          					clst = create_chain(&fp->obj, 0);
   3975          					if (clst == 1) ABORT(fs, FR_INT_ERR);
   3976          					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3977          					fp->obj.sclust = clst;
   3978          				}
   3979          #endif
   3980          				fp->clust = clst;
   3981          			}
   3982          			if (clst != 0) {
   3983          				while (ofs > bcs) {						/* Cluster following loop */
   3984          #if !_FS_READONLY
   3985          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   3986          						clst = create_chain(&fp->obj, clst);	/* Force stretch if in write mode */
   3987          						if (clst == 0) {				/* When disk gets full, clip file size */
   3988          							ofs = bcs; break;
   3989          						}
   3990          					} else
   3991          #endif
   3992          						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
   3993          					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3994          					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
   3995          					fp->clust = clst;
   3996          					fp->fptr += bcs;
   3997          					ofs -= bcs;
   3998          				}
   3999          				fp->fptr += ofs;
   4000          				if (ofs % SS(fs)) {
   4001          					nsect = clust2sect(fs, clst);	/* Current sector */
   4002          					if (!nsect) ABORT(fs, FR_INT_ERR);
   4003          					nsect += (DWORD)(ofs / SS(fs));
   4004          				}
   4005          			}
   4006          		}
   4007          		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
   4008          #if !_FS_TINY
   4009          #if !_FS_READONLY
   4010          			if (fp->flag & _FA_DIRTY) {			/* Write-back dirty sector cache */
   4011          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   4012          					ABORT(fs, FR_DISK_ERR);
   4013          				}
   4014          				fp->flag &= ~_FA_DIRTY;
   4015          			}
   4016          #endif
   4017          			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) {	/* Fill sector cache */
   4018          				ABORT(fs, FR_DISK_ERR);
   4019          			}
   4020          #endif
   4021          			fp->sect = nsect;
   4022          		}
   4023          #if !_FS_READONLY
   4024          		if (fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
   4025          			fp->obj.objsize = fp->fptr;
   4026          			fp->flag |= _FA_MODIFIED;
   4027          		}
   4028          #endif
   4029          	}
   4030          
   4031          	LEAVE_FF(fs, res);
   4032          }
   4033          
   4034          
   4035          
   4036          #if _FS_MINIMIZE <= 1
   4037          /*-----------------------------------------------------------------------*/
   4038          /* Create a Directory Object                                             */
   4039          /*-----------------------------------------------------------------------*/
   4040          
   4041          FRESULT f_opendir (
   4042          	DIR* dp,			/* Pointer to directory object to create */
   4043          	const TCHAR* path	/* Pointer to the directory path */
   4044          )
   4045          {
   4046          	FRESULT res;
   4047          	FATFS *fs;
   4048          	_FDID *obj;
   4049          	DEF_NAMBUF;
   4050          
   4051          
   4052          	if (!dp) return FR_INVALID_OBJECT;
   4053          
   4054          	/* Get logical drive number */
   4055          	obj = &dp->obj;
   4056          	res = find_volume(&path, &fs, 0);
   4057          	if (res == FR_OK) {
   4058          		obj->fs = fs;
   4059          		INIT_NAMBUF(*dp);
   4060          		res = follow_path(dp, path);			/* Follow the path to the directory */
   4061          		if (res == FR_OK) {						/* Follow completed */
   4062          			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
   4063          				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
   4064          #if _FS_EXFAT
   4065          					if (fs->fs_type == FS_EXFAT) {
   4066          						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
   4067          						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
   4068          						obj->c_ofs = dp->blk_ofs;
   4069          						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
   4070          						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   4071          						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   4072          					} else
   4073          #endif
   4074          					{
   4075          						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
   4076          					}
   4077          				} else {						/* This object is a file */
   4078          					res = FR_NO_PATH;
   4079          				}
   4080          			}
   4081          			if (res == FR_OK) {
   4082          				obj->id = fs->id;
   4083          				res = dir_sdi(dp, 0);			/* Rewind directory */
   4084          #if _FS_LOCK != 0
   4085          				if (res == FR_OK) {
   4086          					if (obj->sclust) {
   4087          						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
   4088          						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
   4089          					} else {
   4090          						obj->lockid = 0;	/* Root directory need not to be locked */
   4091          					}
   4092          				}
   4093          #endif
   4094          			}
   4095          		}
   4096          		FREE_NAMBUF();
   4097          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   4098          	}
   4099          	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
   4100          
   4101          	LEAVE_FF(fs, res);
   4102          }
   4103          
   4104          
   4105          
   4106          
   4107          /*-----------------------------------------------------------------------*/
   4108          /* Close Directory                                                       */
   4109          /*-----------------------------------------------------------------------*/
   4110          
   4111          FRESULT f_closedir (
   4112          	DIR *dp		/* Pointer to the directory object to be closed */
   4113          )
   4114          {
   4115          	FRESULT res;
   4116          	FATFS *fs;
   4117          
   4118          
   4119          	res = validate(dp, &fs);
   4120          	if (res == FR_OK) {
   4121          #if _FS_LOCK != 0
   4122          		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
   4123          			res = dec_lock(dp->obj.lockid);
   4124          		}
   4125          		if (res == FR_OK)
   4126          #endif
   4127          		{
   4128          			dp->obj.fs = 0;			/* Invalidate directory object */
   4129          		}
   4130          #if _FS_REENTRANT
   4131          		unlock_fs(fs, FR_OK);		/* Unlock volume */
   4132          #endif
   4133          	}
   4134          	return res;
   4135          }
   4136          
   4137          
   4138          
   4139          
   4140          /*-----------------------------------------------------------------------*/
   4141          /* Read Directory Entries in Sequence                                    */
   4142          /*-----------------------------------------------------------------------*/
   4143          
   4144          FRESULT f_readdir (
   4145          	DIR* dp,			/* Pointer to the open directory object */
   4146          	FILINFO* fno		/* Pointer to file information to return */
   4147          )
   4148          {
   4149          	FRESULT res;
   4150          	FATFS *fs;
   4151          	DEF_NAMBUF;
   4152          
   4153          
   4154          	res = validate(dp, &fs);	/* Check validity of the object */
   4155          	if (res == FR_OK) {
   4156          		if (!fno) {
   4157          			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   4158          		} else {
   4159          			INIT_NAMBUF(*dp);
   4160          			res = dir_read(dp, 0);			/* Read an item */
   4161          			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
   4162          			if (res == FR_OK) {				/* A valid entry is found */
   4163          				get_fileinfo(dp, fno);		/* Get the object information */
   4164          				res = dir_next(dp, 0);		/* Increment index for next */
   4165          				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
   4166          			}
   4167          			FREE_NAMBUF();
   4168          		}
   4169          	}
   4170          	LEAVE_FF(fs, res);
   4171          }
   4172          
   4173          
   4174          
   4175          #if _USE_FIND
   4176          /*-----------------------------------------------------------------------*/
   4177          /* Find Next File                                                        */
   4178          /*-----------------------------------------------------------------------*/
   4179          
   4180          FRESULT f_findnext (
   4181          	DIR* dp,		/* Pointer to the open directory object */
   4182          	FILINFO* fno	/* Pointer to the file information structure */
   4183          )
   4184          {
   4185          	FRESULT res;
   4186          
   4187          
   4188          	for (;;) {
   4189          		res = f_readdir(dp, fno);		/* Get a directory item */
   4190          		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
   4191          		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
   4192          #if _USE_LFN != 0 && _USE_FIND == 2
   4193          		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
   4194          #endif
   4195          	}
   4196          	return res;
   4197          }
   4198          
   4199          
   4200          
   4201          /*-----------------------------------------------------------------------*/
   4202          /* Find First File                                                       */
   4203          /*-----------------------------------------------------------------------*/
   4204          
   4205          FRESULT f_findfirst (
   4206          	DIR* dp,				/* Pointer to the blank directory object */
   4207          	FILINFO* fno,			/* Pointer to the file information structure */
   4208          	const TCHAR* path,		/* Pointer to the directory to open */
   4209          	const TCHAR* pattern	/* Pointer to the matching pattern */
   4210          )
   4211          {
   4212          	FRESULT res;
   4213          
   4214          
   4215          	dp->pat = pattern;		/* Save pointer to pattern string */
   4216          	res = f_opendir(dp, path);		/* Open the target directory */
   4217          	if (res == FR_OK) {
   4218          		res = f_findnext(dp, fno);	/* Find the first item */
   4219          	}
   4220          	return res;
   4221          }
   4222          
   4223          #endif	/* _USE_FIND */
   4224          
   4225          
   4226          
   4227          #if _FS_MINIMIZE == 0
   4228          /*-----------------------------------------------------------------------*/
   4229          /* Get File Status                                                       */
   4230          /*-----------------------------------------------------------------------*/
   4231          
   4232          FRESULT f_stat (
   4233          	const TCHAR* path,	/* Pointer to the file path */
   4234          	FILINFO* fno		/* Pointer to file information to return */
   4235          )
   4236          {
   4237          	FRESULT res;
   4238          	DIR dj;
   4239          	DEF_NAMBUF;
   4240          
   4241          
   4242          	/* Get logical drive number */
   4243          	res = find_volume(&path, &dj.obj.fs, 0);
   4244          	if (res == FR_OK) {
   4245          		INIT_NAMBUF(dj);
   4246          		res = follow_path(&dj, path);	/* Follow the file path */
   4247          		if (res == FR_OK) {				/* Follow completed */
   4248          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
   4249          				res = FR_INVALID_NAME;
   4250          			} else {							/* Found an object */
   4251          				if (fno) get_fileinfo(&dj, fno);
   4252          			}
   4253          		}
   4254          		FREE_NAMBUF();
   4255          	}
   4256          
   4257          	LEAVE_FF(dj.obj.fs, res);
   4258          }
   4259          
   4260          
   4261          
   4262          #if !_FS_READONLY
   4263          /*-----------------------------------------------------------------------*/
   4264          /* Get Number of Free Clusters                                           */
   4265          /*-----------------------------------------------------------------------*/
   4266          
   4267          FRESULT f_getfree (
   4268          	const TCHAR* path,	/* Path name of the logical drive number */
   4269          	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
   4270          	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
   4271          )
   4272          {
   4273          	FRESULT res;
   4274          	FATFS *fs;
   4275          	DWORD nfree, clst, sect, stat;
   4276          	UINT i;
   4277          	BYTE *p;
   4278          	_FDID obj;
   4279          
   4280          
   4281          	/* Get logical drive number */
   4282          	res = find_volume(&path, &fs, 0);
   4283          	if (res == FR_OK) {
   4284          		*fatfs = fs;				/* Return ptr to the fs object */
   4285          		/* If free_clst is valid, return it without full cluster scan */
   4286          		if (fs->free_clst <= fs->n_fatent - 2) {
   4287          			*nclst = fs->free_clst;
   4288          		} else {
   4289          			/* Get number of free clusters */
   4290          			nfree = 0;
   4291          			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
   4292          				clst = 2; obj.fs = fs;
   4293          				do {
   4294          					stat = get_fat(&obj, clst);
   4295          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   4296          					if (stat == 1) { res = FR_INT_ERR; break; }
   4297          					if (stat == 0) nfree++;
   4298          				} while (++clst < fs->n_fatent);
   4299          			} else {
   4300          #if _FS_EXFAT
   4301          				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
   4302          					BYTE bm;
   4303          					UINT b;
   4304          
   4305          					clst = fs->n_fatent - 2;
   4306          					sect = fs->database;
   4307          					i = 0;
   4308          					do {
   4309          						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
   4310          						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
   4311          							if (!(bm & 1)) nfree++;
   4312          							bm >>= 1;
   4313          						}
   4314          						i = (i + 1) & (SS(fs) - 1);
   4315          					} while (clst);
   4316          				} else
   4317          #endif
   4318          				{	/* FAT16/32: Sector alighed FAT entries */
   4319          					clst = fs->n_fatent; sect = fs->fatbase;
   4320          					i = 0; p = 0;
   4321          					do {
   4322          						if (i == 0) {
   4323          							res = move_window(fs, sect++);
   4324          							if (res != FR_OK) break;
   4325          							p = fs->win;
   4326          							i = SS(fs);
   4327          						}
   4328          						if (fs->fs_type == FS_FAT16) {
   4329          							if (ld_word(p) == 0) nfree++;
   4330          							p += 2; i -= 2;
   4331          						} else {
   4332          							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
   4333          							p += 4; i -= 4;
   4334          						}
   4335          					} while (--clst);
   4336          				}
   4337          			}
   4338          			*nclst = nfree;			/* Return the free clusters */
   4339          			fs->free_clst = nfree;	/* Now free_clst is valid */
   4340          			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
   4341          		}
   4342          	}
   4343          
   4344          	LEAVE_FF(fs, res);
   4345          }
   4346          
   4347          
   4348          
   4349          
   4350          /*-----------------------------------------------------------------------*/
   4351          /* Truncate File                                                         */
   4352          /*-----------------------------------------------------------------------*/
   4353          
   4354          FRESULT f_truncate (
   4355          	FIL* fp		/* Pointer to the file object */
   4356          )
   4357          {
   4358          	FRESULT res;
   4359          	FATFS *fs;
   4360          	DWORD ncl;
   4361          
   4362          
   4363          	res = validate(fp, &fs);	/* Check validity of the object */
   4364          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   4365          	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   4366          
   4367          	if (fp->obj.objsize > fp->fptr) {
   4368          		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   4369          			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
   4370          			fp->obj.sclust = 0;
   4371          		} else {				/* When truncate a part of the file, remove remaining clusters */
   4372          			ncl = get_fat(&fp->obj, fp->clust);
   4373          			res = FR_OK;
   4374          			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   4375          			if (ncl == 1) res = FR_INT_ERR;
   4376          			if (res == FR_OK && ncl < fs->n_fatent) {
   4377          				res = remove_chain(&fp->obj, ncl, fp->clust);
   4378          			}
   4379          		}
   4380          		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
   4381          		fp->flag |= _FA_MODIFIED;
   4382          #if !_FS_TINY
   4383          		if (res == FR_OK && (fp->flag & _FA_DIRTY)) {
   4384          			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   4385          				res = FR_DISK_ERR;
   4386          			} else {
   4387          				fp->flag &= ~_FA_DIRTY;
   4388          			}
   4389          		}
   4390          #endif
   4391          		if (res != FR_OK) ABORT(fs, res);
   4392          	}
   4393          
   4394          	LEAVE_FF(fs, res);
   4395          }
   4396          
   4397          
   4398          
   4399          
   4400          /*-----------------------------------------------------------------------*/
   4401          /* Delete a File/Directory                                               */
   4402          /*-----------------------------------------------------------------------*/
   4403          
   4404          FRESULT f_unlink (
   4405          	const TCHAR* path		/* Pointer to the file or directory path */
   4406          )
   4407          {
   4408          	FRESULT res;
   4409          	DIR dj, sdj;
   4410          	DWORD dclst = 0;
   4411          	FATFS *fs;
   4412          #if _FS_EXFAT
   4413          	_FDID obj;
   4414          #endif
   4415          	DEF_NAMBUF;
   4416          
   4417          
   4418          	/* Get logical drive number */
   4419          	res = find_volume(&path, &fs, FA_WRITE);
   4420          	dj.obj.fs = fs;
   4421          	if (res == FR_OK) {
   4422          		INIT_NAMBUF(dj);
   4423          		res = follow_path(&dj, path);		/* Follow the file path */
   4424          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
   4425          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   4426          		}
   4427          #if _FS_LOCK != 0
   4428          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
   4429          #endif
   4430          		if (res == FR_OK) {					/* The object is accessible */
   4431          			if (dj.fn[NSFLAG] & NS_NONAME) {
   4432          				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   4433          			} else {
   4434          				if (dj.obj.attr & AM_RDO) {
   4435          					res = FR_DENIED;		/* Cannot remove R/O object */
   4436          				}
   4437          			}
   4438          			if (res == FR_OK) {
   4439          #if _FS_EXFAT
   4440          				obj.fs = fs;
   4441          				if (fs->fs_type == FS_EXFAT) {
   4442          					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
   4443          					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   4444          					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   4445          				} else
   4446          #endif
   4447          				{
   4448          					dclst = ld_clust(fs, dj.dir);
   4449          				}
   4450          				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
   4451          #if _FS_RPATH != 0
   4452          					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
   4453          						res = FR_DENIED;
   4454          					} else
   4455          #endif
   4456          					{
   4457          						sdj.obj.fs = fs;						/* Open the sub-directory */
   4458          						sdj.obj.sclust = dclst;
   4459          #if _FS_EXFAT
   4460          						if (fs->fs_type == FS_EXFAT) {
   4461          							sdj.obj.objsize = obj.objsize;
   4462          							sdj.obj.stat = obj.stat;
   4463          						}
   4464          #endif
   4465          						res = dir_sdi(&sdj, 0);
   4466          						if (res == FR_OK) {
   4467          							res = dir_read(&sdj, 0);			/* Read an item */
   4468          							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
   4469          							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
   4470          						}
   4471          					}
   4472          				}
   4473          			}
   4474          			if (res == FR_OK) {
   4475          				res = dir_remove(&dj);			/* Remove the directory entry */
   4476          				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
   4477          #if _FS_EXFAT
   4478          					res = remove_chain(&obj, dclst, 0);
   4479          #else
   4480          					res = remove_chain(&dj.obj, dclst, 0);
   4481          #endif
   4482          				}
   4483          				if (res == FR_OK) res = sync_fs(fs);
   4484          			}
   4485          		}
   4486          		FREE_NAMBUF();
   4487          	}
   4488          
   4489          	LEAVE_FF(fs, res);
   4490          }
   4491          
   4492          
   4493          
   4494          
   4495          /*-----------------------------------------------------------------------*/
   4496          /* Create a Directory                                                    */
   4497          /*-----------------------------------------------------------------------*/
   4498          
   4499          FRESULT f_mkdir (
   4500          	const TCHAR* path		/* Pointer to the directory path */
   4501          )
   4502          {
   4503          	FRESULT res;
   4504          	DIR dj;
   4505          	FATFS *fs;
   4506          	BYTE *dir;
   4507          	UINT n;
   4508          	DWORD dsc, dcl, pcl, tm;
   4509          	DEF_NAMBUF;
   4510          
   4511          
   4512          	/* Get logical drive number */
   4513          	res = find_volume(&path, &fs, FA_WRITE);
   4514          	dj.obj.fs = fs;
   4515          	if (res == FR_OK) {
   4516          		INIT_NAMBUF(dj);
   4517          		res = follow_path(&dj, path);			/* Follow the file path */
   4518          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   4519          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
   4520          			res = FR_INVALID_NAME;
   4521          		}
   4522          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   4523          			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
   4524          			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
   4525          			res = FR_OK;
   4526          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   4527          			if (dcl == 1) res = FR_INT_ERR;
   4528          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   4529          			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
   4530          			tm = GET_FATTIME();
   4531          			if (res == FR_OK) {					/* Initialize the new directory table */
   4532          				dsc = clust2sect(fs, dcl);
   4533          				dir = fs->win;
   4534          				mem_set(dir, 0, SS(fs));
   4535          				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   4536          					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
   4537          					dir[DIR_Name] = '.';
   4538          					dir[DIR_Attr] = AM_DIR;
   4539          					st_dword(dir + DIR_WrtTime, tm);
   4540          					st_clust(fs, dir, dcl);
   4541          					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
   4542          					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
   4543          					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase)
   4544          						pcl = 0;
   4545          					st_clust(fs, dir + SZDIRE, pcl);
   4546          				}
   4547          				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   4548          					fs->winsect = dsc++;
   4549          					fs->wflag = 1;
   4550          					res = sync_window(fs);
   4551          					if (res != FR_OK) break;
   4552          					mem_set(dir, 0, SS(fs));
   4553          				}
   4554          			}
   4555          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   4556          			if (res == FR_OK) {
   4557          #if _FS_EXFAT
   4558          				if (fs->fs_type == FS_EXFAT) {
   4559          					st_dword(fs->dirbuf + XDIR_ModTime, tm);
   4560          					st_dword(fs->dirbuf + XDIR_FstClus, dcl);
   4561          					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);
   4562          					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
   4563          					fs->dirbuf[XDIR_GenFlags] = 3;
   4564          					fs->dirbuf[XDIR_Attr] = AM_DIR;
   4565          					res = store_xdir(&dj);
   4566          				} else
   4567          #endif
   4568          				{
   4569          					dir = dj.dir;
   4570          					st_dword(dir + DIR_WrtTime, tm);	/* Created time */
   4571          					st_clust(fs, dir, dcl);				/* Table start cluster */
   4572          					dir[DIR_Attr] = AM_DIR;				/* Attribute */
   4573          					fs->wflag = 1;
   4574          				}
   4575          				res = sync_fs(fs);
   4576          			} else {
   4577          				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
   4578          			}
   4579          		}
   4580          		FREE_NAMBUF();
   4581          	}
   4582          
   4583          	LEAVE_FF(fs, res);
   4584          }
   4585          
   4586          
   4587          
   4588          
   4589          /*-----------------------------------------------------------------------*/
   4590          /* Rename a File/Directory                                               */
   4591          /*-----------------------------------------------------------------------*/
   4592          
   4593          FRESULT f_rename (
   4594          	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
   4595          	const TCHAR* path_new	/* Pointer to the new name */
   4596          )
   4597          {
   4598          	FRESULT res;
   4599          	DIR djo, djn;
   4600          	FATFS *fs;
   4601          	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
   4602          	DWORD dw;
   4603          	DEF_NAMBUF;
   4604          
   4605          
   4606          	get_ldnumber(&path_new);						/* Ignore drive number of new name */
   4607          	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive number of the old object */
   4608          	if (res == FR_OK) {
   4609          		djo.obj.fs = fs;
   4610          		INIT_NAMBUF(djo);
   4611          		res = follow_path(&djo, path_old);		/* Check old object */
   4612          		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
   4613          #if _FS_LOCK != 0
   4614          		if (res == FR_OK) res = chk_lock(&djo, 2);
   4615          #endif
   4616          		if (res == FR_OK) {						/* Object to be renamed is found */
   4617          #if _FS_EXFAT
   4618          			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
   4619          				BYTE nf, nn;
   4620          				WORD nh;
   4621          
   4622          				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
   4623          				mem_cpy(&djn, &djo, sizeof djo);
   4624          				res = follow_path(&djn, path_new);	/* Make sure if new object name is not in use */
   4625          				if (res == FR_OK) res = FR_EXIST;	/* Is new name already in use? */
   4626          				if (res == FR_NO_FILE) { 			/* It is a valid path and no name collision */
   4627          					res = dir_register(&djn);		/* Register the new entry */
   4628          					if (res == FR_OK) {
   4629          						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
   4630          						nh = ld_word(fs->dirbuf + XDIR_NameHash);
   4631          						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
   4632          						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
   4633          						st_word(fs->dirbuf + XDIR_NameHash, nh);
   4634          /* Start of critical section where any interruption can cause a cross-link */
   4635          						res = store_xdir(&djn);
   4636          					}
   4637          				}
   4638          			} else
   4639          #endif
   4640          			{	/* At FAT12/FAT16/FAT32 */
   4641          				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
   4642          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
   4643          				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
   4644          				if (res == FR_OK) res = FR_EXIST;		/* Is new name already in use? */
   4645          				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
   4646          					res = dir_register(&djn);			/* Register the new entry */
   4647          					if (res == FR_OK) {
   4648          						dir = djn.dir;					/* Copy information about object except name */
   4649          						mem_cpy(dir + 13, buf + 2, 19);
   4650          						dir[DIR_Attr] = buf[0] | AM_ARC;
   4651          						fs->wflag = 1;
   4652          						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
   4653          							dw = clust2sect(fs, ld_clust(fs, dir));
   4654          							if (!dw) {
   4655          								res = FR_INT_ERR;
   4656          							} else {
   4657          /* Start of critical section where any interruption can cause a cross-link */
   4658          								res = move_window(fs, dw);
   4659          								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
   4660          								if (res == FR_OK && dir[1] == '.') {
   4661          									st_clust(fs, dir, djn.obj.sclust);
   4662          									fs->wflag = 1;
   4663          								}
   4664          							}
   4665          						}
   4666          					}
   4667          				}
   4668          			}
   4669          			if (res == FR_OK) {
   4670          				res = dir_remove(&djo);		/* Remove old entry */
   4671          				if (res == FR_OK) {
   4672          					res = sync_fs(fs);
   4673          				}
   4674          			}
   4675          /* End of critical section */
   4676          		}
   4677          		FREE_NAMBUF();
   4678          	}
   4679          
   4680          	LEAVE_FF(fs, res);
   4681          }
   4682          
   4683          
   4684          
   4685          #endif /* !_FS_READONLY */
   4686          #endif /* _FS_MINIMIZE == 0 */
   4687          #endif /* _FS_MINIMIZE <= 1 */
   4688          #endif /* _FS_MINIMIZE <= 2 */
   4689          
   4690          
   4691          
   4692          #if _USE_CHMOD && !_FS_READONLY
   4693          /*-----------------------------------------------------------------------*/
   4694          /* Change Attribute                                                      */
   4695          /*-----------------------------------------------------------------------*/
   4696          
   4697          FRESULT f_chmod (
   4698          	const TCHAR* path,	/* Pointer to the file path */
   4699          	BYTE attr,			/* Attribute bits */
   4700          	BYTE mask			/* Attribute mask to change */
   4701          )
   4702          {
   4703          	FRESULT res;
   4704          	DIR dj;
   4705          	FATFS *fs;
   4706          	DEF_NAMBUF;
   4707          
   4708          
   4709          	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
   4710          	dj.obj.fs = fs;
   4711          	if (res == FR_OK) {
   4712          		INIT_NAMBUF(dj);
   4713          		res = follow_path(&dj, path);	/* Follow the file path */
   4714          		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
   4715          		if (res == FR_OK) {
   4716          			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   4717          #if _FS_EXFAT
   4718          			if (fs->fs_type == FS_EXFAT) {
   4719          				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   4720          				res = store_xdir(&dj);
   4721          			} else
   4722          #endif
   4723          			{
   4724          				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   4725          				fs->wflag = 1;
   4726          			}
   4727          			res = sync_fs(fs);
   4728          		}
   4729          		FREE_NAMBUF();
   4730          	}
   4731          
   4732          	LEAVE_FF(fs, res);
   4733          }
   4734          
   4735          
   4736          
   4737          
   4738          /*-----------------------------------------------------------------------*/
   4739          /* Change Timestamp                                                      */
   4740          /*-----------------------------------------------------------------------*/
   4741          
   4742          FRESULT f_utime (
   4743          	const TCHAR* path,	/* Pointer to the file/directory name */
   4744          	const FILINFO* fno	/* Pointer to the time stamp to be set */
   4745          )
   4746          {
   4747          	FRESULT res;
   4748          	DIR dj;
   4749          	FATFS *fs;
   4750          	DEF_NAMBUF;
   4751          
   4752          
   4753          	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
   4754          	dj.obj.fs = fs;
   4755          	if (res == FR_OK) {
   4756          		INIT_NAMBUF(dj);
   4757          		res = follow_path(&dj, path);	/* Follow the file path */
   4758          		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
   4759          		if (res == FR_OK) {
   4760          #if _FS_EXFAT
   4761          			if (fs->fs_type == FS_EXFAT) {
   4762          				st_word(fs->dirbuf + XDIR_ModTime, fno->ftime);
   4763          				st_word(fs->dirbuf + XDIR_ModTime + 2, fno->fdate);
   4764          				res = store_xdir(&dj);
   4765          			} else
   4766          #endif
   4767          			{
   4768          				st_word(dj.dir + DIR_WrtTime, fno->ftime);
   4769          				st_word(dj.dir + DIR_WrtDate, fno->fdate);
   4770          				fs->wflag = 1;
   4771          			}
   4772          			if (res == FR_OK) res = sync_fs(fs);
   4773          		}
   4774          		FREE_NAMBUF();
   4775          	}
   4776          
   4777          	LEAVE_FF(fs, res);
   4778          }
   4779          
   4780          #endif	/* _USE_CHMOD && !_FS_READONLY */
   4781          
   4782          
   4783          
   4784          #if _USE_LABEL
   4785          /*-----------------------------------------------------------------------*/
   4786          /* Get Volume Label                                                      */
   4787          /*-----------------------------------------------------------------------*/
   4788          
   4789          FRESULT f_getlabel (
   4790          	const TCHAR* path,	/* Path name of the logical drive number */
   4791          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   4792          	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
   4793          )
   4794          {
   4795          	FRESULT res;
   4796          	DIR dj;
   4797          	FATFS *fs;
   4798          	UINT si, di;
   4799          #if _LFN_UNICODE || _FS_EXFAT
   4800          	WCHAR w;
   4801          #endif
   4802          
   4803          	/* Get logical drive number */
   4804          	res = find_volume(&path, &fs, 0);
   4805          
   4806          	/* Get volume label */
   4807          	if (res == FR_OK && label) {
   4808          		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
   4809          		res = dir_sdi(&dj, 0);
   4810          		if (res == FR_OK) {
   4811          		 	res = dir_read(&dj, 1);			/* Find a volume label entry */
   4812          		 	if (res == FR_OK) {
   4813          #if _FS_EXFAT
   4814          				if (fs->fs_type == FS_EXFAT) {
   4815          					for (si = di = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
   4816          						w = ld_word(dj.dir + XDIR_Label + si * 2);
   4817          #if _LFN_UNICODE
   4818          						label[di++] = w;
   4819          #else
   4820          						w = ff_convert(w, 0);	/* Unicode -> OEM */
   4821          						if (w == 0) w = '?';	/* Replace wrong character */
   4822          						if (_DF1S && w >= 0x100) label[di++] = (char)(w >> 8);
   4823          						label[di++] = (char)w;
   4824          #endif
   4825          					}
   4826          					label[di] = 0;
   4827          				} else
   4828          #endif
   4829          				{
   4830          					si = di = 0;		/* Extract volume label from AM_VOL entry with code comversion */
   4831          					do {
   4832          #if _LFN_UNICODE
   4833          						w = (si < 11) ? dj.dir[si++] : ' ';
   4834          						if (IsDBCS1(w) && si < 11 && IsDBCS2(dj.dir[si])) {
   4835          							w = w << 8 | dj.dir[si++];
   4836          						}
   4837          						label[di++] = ff_convert(w, 1);	/* OEM -> Unicode */
   4838          #else
   4839          						label[di++] = dj.dir[si++];
   4840          #endif
   4841          					} while (di < 11);
   4842          					do {				/* Truncate trailing spaces */
   4843          						label[di] = 0;
   4844          						if (di == 0) break;
   4845          					} while (label[--di] == ' ');
   4846          				}
   4847          			}
   4848          		}
   4849          		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
   4850          			label[0] = 0;
   4851          			res = FR_OK;
   4852          		}
   4853          	}
   4854          
   4855          	/* Get volume serial number */
   4856          	if (res == FR_OK && vsn) {
   4857          		res = move_window(fs, fs->volbase);
   4858          		if (res == FR_OK) {
   4859          			switch (fs->fs_type) {
   4860          			case FS_EXFAT: di = BPB_VolIDEx; break;
   4861          			case FS_FAT32: di = BS_VolID32; break;
   4862          			default:       di = BS_VolID;
   4863          			}
   4864          			*vsn = ld_dword(&fs->win[di]);
   4865          		}
   4866          	}
   4867          
   4868          	LEAVE_FF(fs, res);
   4869          }
   4870          
   4871          
   4872          
   4873          #if !_FS_READONLY
   4874          /*-----------------------------------------------------------------------*/
   4875          /* Set Volume Label                                                      */
   4876          /*-----------------------------------------------------------------------*/
   4877          
   4878          FRESULT f_setlabel (
   4879          	const TCHAR* label	/* Pointer to the volume label to set */
   4880          )
   4881          {
   4882          	FRESULT res;
   4883          	DIR dj;
   4884          	FATFS *fs;
   4885          	BYTE dirvn[22];
   4886          	UINT i, j, slen;
   4887          	WCHAR w;
   4888          	static const char badchr[] = "\"*+,.:;<=>\?[]|\x7F";
   4889          
   4890          
   4891          	/* Get logical drive number */
   4892          	res = find_volume(&label, &fs, FA_WRITE);
   4893          	if (res != FR_OK) LEAVE_FF(fs, res);
   4894          	dj.obj.fs = fs;
   4895          
   4896          	/* Get length of given volume label */
   4897          	for (slen = 0; (UINT)label[slen] >= ' '; slen++) ;	/* Get name length */
   4898          
   4899          #if _FS_EXFAT
   4900          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   4901          		for (i = j = 0; i < slen; ) {	/* Create volume label in directory form */
   4902          			w = label[i++];
   4903          #if !_LFN_UNICODE
   4904          			if (IsDBCS1(w)) {
   4905          				w = (i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   4906          			}
   4907          			w = ff_convert(w, 1);
   4908          #endif
   4909          			if (w == 0 || chk_chr(badchr, w) || j == 22) {	/* Check validity check validity of the volume label */
   4910          				LEAVE_FF(fs, FR_INVALID_NAME);
   4911          			}
   4912          			st_word(dirvn + j, w); j += 2;
   4913          		}
   4914          		slen = j;
   4915          	} else
   4916          #endif
   4917          	{	/* At the FAT12/16/32 */
   4918          		for ( ; slen && label[slen - 1] == ' '; slen--) ;	/* Remove trailing spaces */
   4919          		if (slen) {		/* Is there a volume label to be set? */
   4920          			dirvn[0] = 0; i = j = 0;	/* Create volume label in directory form */
   4921          			do {
   4922          #if _LFN_UNICODE
   4923          				w = ff_convert(ff_wtoupper(label[i++]), 0);
   4924          #else
   4925          				w = (BYTE)label[i++];
   4926          				if (IsDBCS1(w)) {
   4927          					w = (j < 10 && i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   4928          				}
   4929          #if _USE_LFN != 0
   4930          				w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   4931          #else
   4932          				if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
   4933          #ifdef _EXCVT
   4934          				if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
   4935          #else
   4936          				if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
   4937          #endif
   4938          #endif
   4939          #endif
   4940          				if (w == 0 || chk_chr(badchr, w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
   4941          					LEAVE_FF(fs, FR_INVALID_NAME);
   4942          				}
   4943          				if (w >= 0x100) dirvn[j++] = (BYTE)(w >> 8);
   4944          				dirvn[j++] = (BYTE)w;
   4945          			} while (i < slen);
   4946          			while (j < 11) dirvn[j++] = ' ';	/* Fill remaining name field */
   4947          			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
   4948          		}
   4949          	}
   4950          
   4951          	/* Set volume label */
   4952          	dj.obj.sclust = 0;		/* Open root directory */
   4953          	res = dir_sdi(&dj, 0);
   4954          	if (res == FR_OK) {
   4955          		res = dir_read(&dj, 1);	/* Get volume label entry */
   4956          		if (res == FR_OK) {
   4957          			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
   4958          				dj.dir[XDIR_NumLabel] = slen / 2;	/* Change the volume label */
   4959          				mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
   4960          			} else {
   4961          				if (slen) {
   4962          					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
   4963          				} else {
   4964          					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
   4965          				}
   4966          			}
   4967          			fs->wflag = 1;
   4968          			res = sync_fs(fs);
   4969          		} else {			/* No volume label entry is found or error */
   4970          			if (res == FR_NO_FILE) {
   4971          				res = FR_OK;
   4972          				if (slen) {	/* Create a volume label entry */
   4973          					res = dir_alloc(&dj, 1);	/* Allocate an entry */
   4974          					if (res == FR_OK) {
   4975          						mem_set(dj.dir, 0, SZDIRE);	/* Clear the entry */
   4976          						if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
   4977          							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
   4978          							dj.dir[XDIR_NumLabel] = slen / 2;
   4979          							mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
   4980          						} else {
   4981          							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
   4982          							mem_cpy(dj.dir, dirvn, 11);
   4983          						}
   4984          						fs->wflag = 1;
   4985          						res = sync_fs(fs);
   4986          					}
   4987          				}
   4988          			}
   4989          		}
   4990          	}
   4991          
   4992          	LEAVE_FF(fs, res);
   4993          }
   4994          
   4995          #endif /* !_FS_READONLY */
   4996          #endif /* _USE_LABEL */
   4997          
   4998          
   4999          
   5000          #if _USE_EXPAND && !_FS_READONLY
   5001          /*-----------------------------------------------------------------------*/
   5002          /* Allocate a Contiguous Blocks to the File                              */
   5003          /*-----------------------------------------------------------------------*/
   5004          
   5005          FRESULT f_expand (
   5006          	FIL* fp,		/* Pointer to the file object */
   5007          	FSIZE_t fsz,	/* File size to be expanded to */
   5008          	BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
   5009          )
   5010          {
   5011          	FRESULT res;
   5012          	FATFS *fs;
   5013          	DWORD val, clst, csz, stcl, scl, ncl, tcl;
   5014          
   5015          
   5016          	res = validate(fp, &fs);		/* Check validity of the object */
   5017          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   5018          	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
   5019          #if _FS_EXFAT
   5020          	if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
   5021          #endif
   5022          	csz = (DWORD)fs->csize * SS(fs);	/* Cluster size */
   5023          	tcl = (DWORD)(fsz / csz) + ((fsz & (csz - 1)) ? 1 : 0);	/* Number of clusters required */
   5024          	stcl = fs->last_clst;
   5025          	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
   5026          
   5027          #if _FS_EXFAT
   5028          	if (fs->fs_type == FS_EXFAT) {
   5029          		scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
   5030          		if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
   5031          		if (scl == 1) res = FR_INT_ERR;
   5032          		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
   5033          		if (res == FR_OK) {
   5034          			if (opt) {
   5035          				res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
   5036          				fs->last_clst = scl + tcl - 1;
   5037          			} else {
   5038          				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
   5039          			}
   5040          		}
   5041          	} else
   5042          #endif
   5043          	{
   5044          		scl = clst = stcl; ncl = 0;
   5045          		for (;;) {	/* Find a contiguous cluster block */
   5046          			val = get_fat(&fp->obj, clst);
   5047          			if (++clst >= fs->n_fatent) clst = 2;
   5048          			if (val == 1) { res = FR_INT_ERR; break; }
   5049          			if (val == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   5050          			if (val == 0) {	/* Is it a free cluster? */
   5051          				if (++ncl == tcl) break;	/* Break if a contiguous cluster block was found */
   5052          			} else {
   5053          				scl = clst; ncl = 0;		/* Not a free cluster */
   5054          			}
   5055          			if (clst == stcl) { res = FR_DENIED; break; }	/* All cluster scanned? */
   5056          		}
   5057          		if (res == FR_OK) {
   5058          			if (opt) {
   5059          				for (clst = scl; tcl; clst++, tcl--) {	/* Create a cluster chain on the FAT */
   5060          					val = (tcl == 1) ? 0xFFFFFFFF : clst + 1;
   5061          					res = put_fat(fs, clst, val);
   5062          					if (res != FR_OK) break;
   5063          					fs->last_clst = clst;
   5064          				}
   5065          			} else {
   5066          				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
   5067          			}
   5068          		}
   5069          	}
   5070          
   5071          	if (opt && res == FR_OK) {
   5072          		fp->obj.sclust = scl;		/* Update allocation information */
   5073          		fp->obj.objsize = fsz;
   5074          		if (_FS_EXFAT) fp->obj.stat = 2;
   5075          		fp->flag |= _FA_MODIFIED;
   5076          	}
   5077          
   5078          	LEAVE_FF(fs, res);
   5079          }
   5080          
   5081          #endif /* _USE_EXPAND && !_FS_READONLY */
   5082          
   5083          
   5084          
   5085          /*-----------------------------------------------------------------------*/
   5086          /* Forward data to the stream directly (available on only tiny cfg)      */
   5087          /*-----------------------------------------------------------------------*/
   5088          #if _USE_FORWARD && _FS_TINY
   5089          
   5090          FRESULT f_forward (
   5091          	FIL* fp, 						/* Pointer to the file object */
   5092          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   5093          	UINT btf,						/* Number of bytes to forward */
   5094          	UINT* bf						/* Pointer to number of bytes forwarded */
   5095          )
   5096          {
   5097          	FRESULT res;
   5098          	FATFS *fs;
   5099          	DWORD clst, sect;
   5100          	FSIZE_t remain;
   5101          	UINT rcnt, csect;
   5102          
   5103          
   5104          	*bf = 0;	/* Clear transfer byte counter */
   5105          	res = validate(fp, &fs);		/* Check validity of the object */
   5106          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   5107          	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   5108          
   5109          	remain = fp->fsize - fp->fptr;
   5110          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   5111          
   5112          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   5113          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   5114          		csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
   5115          		if ((fp->fptr % SS(fs)) == 0) {				/* On the sector boundary? */
   5116          			if (csect == 0) {						/* On the cluster boundary? */
   5117          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   5118          					fp->sclust : get_fat(fs, fp->clust);
   5119          				if (clst <= 1) ABORT(fs, FR_INT_ERR);
   5120          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   5121          				fp->clust = clst;					/* Update current cluster */
   5122          			}
   5123          		}
   5124          		sect = clust2sect(fs, fp->clust);			/* Get current data sector */
   5125          		if (!sect) ABORT(fs, FR_INT_ERR);
   5126          		sect += csect;
   5127          		if (move_window(fs, sect) != FR_OK) {		/* Move sector window */
   5128          			ABORT(fs, FR_DISK_ERR);
   5129          		}
   5130          		fp->sect = sect;
   5131          		rcnt = SS(fs) - (WORD)(fp->fptr % SS(fs));	/* Forward data from sector window */
   5132          		if (rcnt > btf) rcnt = btf;
   5133          		rcnt = (*func)(&fs->win[(WORD)fp->fptr % SS(fs)], rcnt);
   5134          		if (!rcnt) ABORT(fs, FR_INT_ERR);
   5135          	}
   5136          
   5137          	LEAVE_FF(fs, FR_OK);
   5138          }
   5139          #endif /* _USE_FORWARD */
   5140          
   5141          
   5142          
   5143          #if _USE_MKFS && !_FS_READONLY
   5144          /*-----------------------------------------------------------------------*/
   5145          /* Create file system on the logical drive                               */
   5146          /*-----------------------------------------------------------------------*/
   5147          #define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
   5148          #define N_FATS		1		/* Number of FATs (1 or 2) */
   5149          
   5150          
   5151          FRESULT f_mkfs (
   5152          	const TCHAR* path,	/* Logical drive number */
   5153          	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
   5154          	UINT au				/* Size of allocation unit in unit of byte or sector */
   5155          )
   5156          {
   5157          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   5158          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   5159          	int vol;
   5160          	BYTE fmt, md, sys, *tbl, pdrv, part;
   5161          	DWORD n_clst, vs, n, wsect;
   5162          	UINT i;
   5163          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   5164          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   5165          	FATFS *fs;
   5166          	DSTATUS stat;
   5167          #if _USE_TRIM
   5168          	DWORD eb[2];
   5169          #endif
   5170          
   5171          
   5172          	/* Check mounted drive and clear work area */
   5173          	if (sfd > 1) return FR_INVALID_PARAMETER;
   5174          	vol = get_ldnumber(&path);				/* Get target volume */
   5175          	if (vol < 0) return FR_INVALID_DRIVE;
   5176          	fs = FatFs[vol];						/* Check if the volume has work area */
   5177          	if (!fs) return FR_NOT_ENABLED;
   5178          	fs->fs_type = 0;
   5179          	pdrv = LD2PD(vol);	/* Physical drive */
   5180          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   5181          
   5182          	/* Get disk statics */
   5183          	stat = disk_initialize(pdrv);
   5184          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5185          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5186          #if _MAX_SS != _MIN_SS		/* Get disk sector size */
   5187          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS) {
   5188          		return FR_DISK_ERR;
   5189          	}
   5190          #endif
   5191          	if (_MULTI_PARTITION && part) {
   5192          		/* Get partition information from partition table in the MBR */
   5193          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   5194          		if (ld_word(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   5195          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5196          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   5197          		b_vol = ld_dword(tbl + 8);	/* Volume start sector */
   5198          		n_vol = ld_dword(tbl + 12);	/* Volume size */
   5199          	} else {
   5200          		/* Create a single-partition in this function */
   5201          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128) {
   5202          			return FR_DISK_ERR;
   5203          		}
   5204          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   5205          		n_vol -= b_vol;				/* Volume size */
   5206          	}
   5207          
   5208          	if (au & (au - 1)) au = 0;
   5209          	if (!au) {						/* AU auto selection */
   5210          		vs = n_vol / (2000 / (SS(fs) / 512));
   5211          		for (i = 0; vs < vst[i]; i++) ;
   5212          		au = cst[i];
   5213          	}
   5214          	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
   5215          	if (!au) au = 1;
   5216          	if (au > 128) au = 128;
   5217          
   5218          	/* Pre-compute number of clusters and FAT sub-type */
   5219          	n_clst = n_vol / au;
   5220          	fmt = FS_FAT12;
   5221          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   5222          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   5223          
   5224          	/* Determine offset and size of FAT structure */
   5225          	if (fmt == FS_FAT32) {
   5226          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   5227          		n_rsv = 32;
   5228          		n_dir = 0;
   5229          	} else {
   5230          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   5231          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   5232          		n_rsv = 1;
   5233          		n_dir = (DWORD)N_ROOTDIR * SZDIRE / SS(fs);
   5234          	}
   5235          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   5236          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   5237          	b_data = b_dir + n_dir;				/* Data area start sector */
   5238          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   5239          
   5240          	/* Align data start sector to erase block boundary (for flash memory media) */
   5241          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   5242          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   5243          	n = (n - b_data) / N_FATS;
   5244          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   5245          		n_rsv += n;
   5246          		b_fat += n;
   5247          	} else {					/* FAT12/16: Expand FAT size */
   5248          		n_fat += n;
   5249          	}
   5250          
   5251          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   5252          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   5253          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   5254          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32)) {
   5255          		return FR_MKFS_ABORTED;
   5256          	}
   5257          
   5258          	/* Determine system ID in the partition table */
   5259          	if (fmt == FS_FAT32) {
   5260          		sys = 0x0C;		/* FAT32X */
   5261          	} else {
   5262          		if (fmt == FS_FAT12 && n_vol < 0x10000) {
   5263          			sys = 0x01;	/* FAT12(<65536) */
   5264          		} else {
   5265          			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
   5266          		}
   5267          	}
   5268          
   5269          	if (_MULTI_PARTITION && part) {
   5270          		/* Update system ID in the partition table */
   5271          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5272          		tbl[4] = sys;
   5273          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to teh MBR */
   5274          			return FR_DISK_ERR;
   5275          		}
   5276          		md = 0xF8;
   5277          	} else {
   5278          		if (sfd) {	/* No partition table (SFD) */
   5279          			md = 0xF0;
   5280          		} else {	/* Create partition table (FDISK) */
   5281          			mem_set(fs->win, 0, SS(fs));
   5282          			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
   5283          			tbl[1] = 1;						/* Partition start head */
   5284          			tbl[2] = 1;						/* Partition start sector */
   5285          			tbl[3] = 0;						/* Partition start cylinder */
   5286          			tbl[4] = sys;					/* System type */
   5287          			tbl[5] = 254;					/* Partition end head */
   5288          			n = (b_vol + n_vol) / 63 / 255;
   5289          			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
   5290          			tbl[7] = (BYTE)n;				/* End cylinder */
   5291          			st_dword(tbl + 8, 63);			/* Partition start in LBA */
   5292          			st_dword(tbl + 12, n_vol);		/* Partition size in LBA */
   5293          			st_word(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
   5294          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to the MBR */
   5295          				return FR_DISK_ERR;
   5296          			}
   5297          			md = 0xF8;
   5298          		}
   5299          	}
   5300          
   5301          	/* Create BPB in the VBR */
   5302          	tbl = fs->win;							/* Clear sector */
   5303          	mem_set(tbl, 0, SS(fs));
   5304          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   5305          	i = SS(fs);								/* Sector size */
   5306          	st_word(tbl + BPB_BytsPerSec, (WORD)i);
   5307          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   5308          	st_word(tbl + BPB_RsvdSecCnt, (WORD)n_rsv);	/* Reserved sectors */
   5309          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   5310          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
   5311          	st_word(tbl + BPB_RootEntCnt, (WORD)i);
   5312          	if (n_vol < 0x10000) {					/* Number of total sectors */
   5313          		st_word(tbl + BPB_TotSec16, (WORD)n_vol);
   5314          	} else {
   5315          		st_dword(tbl + BPB_TotSec32, (WORD)n_vol);
   5316          	}
   5317          	tbl[BPB_Media] = md;					/* Media descriptor */
   5318          	st_word(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
   5319          	st_word(tbl + BPB_NumHeads, 255);		/* Number of heads */
   5320          	st_dword(tbl + BPB_HiddSec, b_vol);		/* Volume offset */
   5321          	n = GET_FATTIME();						/* Use current time as VSN */
   5322          	if (fmt == FS_FAT32) {
   5323          		st_dword(tbl + BS_VolID32, n);		/* VSN */
   5324          		st_dword(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   5325          		st_dword(tbl + BPB_RootClus32, 2);	/* Root directory start cluster (2) */
   5326          		st_word(tbl + BPB_FSInfo32, 1);		/* FSINFO record offset (VBR + 1) */
   5327          		st_word(tbl + BPB_BkBootSec32, 6);	/* Backup boot record offset (VBR + 6) */
   5328          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   5329          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   5330          		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   5331          	} else {
   5332          		st_dword(tbl + BS_VolID, n);		/* VSN */
   5333          		st_word(tbl + BPB_FATSz16, (WORD)n_fat);	/* Number of sectors per FAT */
   5334          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   5335          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   5336          		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   5337          	}
   5338          	st_word(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   5339          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) {	/* Write it to the VBR sector */
   5340          		return FR_DISK_ERR;
   5341          	}
   5342          	if (fmt == FS_FAT32) {					/* Write it to the backup VBR if needed (VBR + 6) */
   5343          		disk_write(pdrv, tbl, b_vol + 6, 1);
   5344          	}
   5345          
   5346          	/* Initialize FAT area */
   5347          	wsect = b_fat;
   5348          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   5349          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   5350          		n = md;								/* Media descriptor byte */
   5351          		if (fmt != FS_FAT32) {
   5352          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   5353          			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
   5354          		} else {
   5355          			n |= 0xFFFFFF00;
   5356          			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
   5357          			st_dword(tbl + 4, 0xFFFFFFFF);
   5358          			st_dword(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
   5359          		}
   5360          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5361          			return FR_DISK_ERR;
   5362          		}
   5363          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   5364          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   5365          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5366          				return FR_DISK_ERR;
   5367          			}
   5368          		}
   5369          	}
   5370          
   5371          	/* Initialize root directory */
   5372          	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
   5373          	do {
   5374          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5375          			return FR_DISK_ERR;
   5376          		}
   5377          	} while (--i);
   5378          
   5379          #if _USE_TRIM	/* Erase data area if needed */
   5380          	{
   5381          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   5382          		disk_ioctl(pdrv, CTRL_TRIM, eb);
   5383          	}
   5384          #endif
   5385          
   5386          	/* Create FSINFO if needed */
   5387          	if (fmt == FS_FAT32) {
   5388          		st_dword(tbl + FSI_LeadSig, 0x41615252);
   5389          		st_dword(tbl + FSI_StrucSig, 0x61417272);
   5390          		st_dword(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   5391          		st_dword(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
   5392          		st_word(tbl + BS_55AA, 0xAA55);
   5393          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
   5394          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
   5395          	}
   5396          
   5397          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   5398          }
   5399          
   5400          
   5401          
   5402          #if _MULTI_PARTITION
   5403          /*-----------------------------------------------------------------------*/
   5404          /* Create partition table on the physical drive                          */
   5405          /*-----------------------------------------------------------------------*/
   5406          
   5407          FRESULT f_fdisk (
   5408          	BYTE pdrv,			/* Physical drive number */
   5409          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   5410          	void* work			/* Pointer to the working buffer */
   5411          )
   5412          {
   5413          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   5414          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   5415          	DSTATUS stat;
   5416          	DWORD sz_disk, sz_part, s_part;
   5417          
   5418          
   5419          	stat = disk_initialize(pdrv);
   5420          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5421          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5422          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   5423          
   5424          	/* Determine CHS in the table regardless of the drive geometry */
   5425          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   5426          	if (n == 256) n--;
   5427          	e_hd = n - 1;
   5428          	sz_cyl = 63 * n;
   5429          	tot_cyl = sz_disk / sz_cyl;
   5430          
   5431          	/* Create partition table */
   5432          	mem_set(buf, 0, _MAX_SS);
   5433          	p = buf + MBR_Table; b_cyl = 0;
   5434          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   5435          		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   5436          		if (!p_cyl) continue;
   5437          		s_part = (DWORD)sz_cyl * b_cyl;
   5438          		sz_part = (DWORD)sz_cyl * p_cyl;
   5439          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   5440          			s_hd = 1;
   5441          			s_part += 63; sz_part -= 63;
   5442          		} else {
   5443          			s_hd = 0;
   5444          		}
   5445          		e_cyl = b_cyl + p_cyl - 1;
   5446          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   5447          
   5448          		/* Set partition table */
   5449          		p[1] = s_hd;						/* Start head */
   5450          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   5451          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   5452          		p[4] = 0x06;						/* System type (temporary setting) */
   5453          		p[5] = e_hd;						/* End head */
   5454          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   5455          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   5456          		st_dword(p + 8, s_part);			/* Start sector in LBA */
   5457          		st_dword(p + 12, sz_part);			/* Partition size */
   5458          
   5459          		/* Next partition */
   5460          		b_cyl += p_cyl;
   5461          	}
   5462          	st_word(p, 0xAA55);
   5463          
   5464          	/* Write it to the MBR */
   5465          	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
   5466          }
   5467          
   5468          
   5469          #endif /* _MULTI_PARTITION */
   5470          #endif /* _USE_MKFS && !_FS_READONLY */
   5471          
   5472          
   5473          
   5474          
   5475          #if _USE_STRFUNC
   5476          /*-----------------------------------------------------------------------*/
   5477          /* Get a string from the file                                            */
   5478          /*-----------------------------------------------------------------------*/
   5479          
   5480          TCHAR* f_gets (
   5481          	TCHAR* buff,	/* Pointer to the string buffer to read */
   5482          	int len,		/* Size of string buffer (characters) */
   5483          	FIL* fp			/* Pointer to the file object */
   5484          )
   5485          {
   5486          	int n = 0;
   5487          	TCHAR c, *p = buff;
   5488          	BYTE s[2];
   5489          	UINT rc;
   5490          
   5491          
   5492          	while (n < len - 1) {	/* Read characters until buffer gets filled */
   5493          #if _LFN_UNICODE
   5494          #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
   5495          		f_read(fp, s, 1, &rc);
   5496          		if (rc != 1) break;
   5497          		c = s[0];
   5498          		if (c >= 0x80) {
   5499          			if (c < 0xC0) continue;	/* Skip stray trailer */
   5500          			if (c < 0xE0) {			/* Two-byte sequence */
   5501          				f_read(fp, s, 1, &rc);
   5502          				if (rc != 1) break;
   5503          				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
   5504          				if (c < 0x80) c = '?';
   5505          			} else {
   5506          				if (c < 0xF0) {		/* Three-byte sequence */
   5507          					f_read(fp, s, 2, &rc);
   5508          					if (rc != 2) break;
   5509          					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
   5510          					if (c < 0x800) c = '?';
   5511          				} else {			/* Reject four-byte sequence */
   5512          					c = '?';
   5513          				}
   5514          			}
   5515          		}
   5516          #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
   5517          		f_read(fp, s, 2, &rc);
   5518          		if (rc != 2) break;
   5519          		c = s[1] + (s[0] << 8);
   5520          #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
   5521          		f_read(fp, s, 2, &rc);
   5522          		if (rc != 2) break;
   5523          		c = s[0] + (s[1] << 8);
   5524          #else						/* Read a character in ANSI/OEM */
   5525          		f_read(fp, s, 1, &rc);
   5526          		if (rc != 1) break;
   5527          		c = s[0];
   5528          		if (IsDBCS1(c)) {
   5529          			f_read(fp, s, 1, &rc);
   5530          			if (rc != 1) break;
   5531          			c = (c << 8) + s[0];
   5532          		}
   5533          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   5534          		if (!c) c = '?';
   5535          #endif
   5536          #else						/* Read a character without conversion */
   5537          		f_read(fp, s, 1, &rc);
   5538          		if (rc != 1) break;
   5539          		c = s[0];
   5540          #endif
   5541          		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
   5542          		*p++ = c;
   5543          		n++;
   5544          		if (c == '\n') break;		/* Break on EOL */
   5545          	}
   5546          	*p = 0;
   5547          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   5548          }
   5549          
   5550          
   5551          
   5552          
   5553          #if !_FS_READONLY
   5554          #include <stdarg.h>
   5555          /*-----------------------------------------------------------------------*/
   5556          /* Put a character to the file                                           */
   5557          /*-----------------------------------------------------------------------*/
   5558          
   5559          typedef struct {
   5560          	FIL* fp;
   5561          	int idx, nchr;
   5562          	BYTE buf[64];
   5563          } putbuff;
   5564          
   5565          
   5566          static
   5567          void putc_bfd (
   5568          	putbuff* pb,
   5569          	TCHAR c
   5570          )
   5571          {
   5572          	UINT bw;
   5573          	int i;
   5574          
   5575          
   5576          	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
   5577          		putc_bfd(pb, '\r');
   5578          	}
   5579          
   5580          	i = pb->idx;	/* Buffer write index (-1:error) */
   5581          	if (i < 0) return;
   5582          
   5583          #if _LFN_UNICODE
   5584          #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
   5585          	if (c < 0x80) {				/* 7-bit */
   5586          		pb->buf[i++] = (BYTE)c;
   5587          	} else {
   5588          		if (c < 0x800) {		/* 11-bit */
   5589          			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
   5590          		} else {				/* 16-bit */
   5591          			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
   5592          			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
   5593          		}
   5594          		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
   5595          	}
   5596          #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
   5597          	pb->buf[i++] = (BYTE)(c >> 8);
   5598          	pb->buf[i++] = (BYTE)c;
   5599          #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
   5600          	pb->buf[i++] = (BYTE)c;
   5601          	pb->buf[i++] = (BYTE)(c >> 8);
   5602          #else							/* Write a character in ANSI/OEM */
   5603          	c = ff_convert(c, 0);	/* Unicode -> OEM */
   5604          	if (!c) c = '?';
   5605          	if (c >= 0x100)
   5606          		pb->buf[i++] = (BYTE)(c >> 8);
   5607          	pb->buf[i++] = (BYTE)c;
   5608          #endif
   5609          #else							/* Write a character without conversion */
   5610          	pb->buf[i++] = (BYTE)c;
   5611          #endif
   5612          
   5613          	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
   5614          		f_write(pb->fp, pb->buf, (UINT)i, &bw);
   5615          		i = (bw == (UINT)i) ? 0 : -1;
   5616          	}
   5617          	pb->idx = i;
   5618          	pb->nchr++;
   5619          }
   5620          
   5621          
   5622          
   5623          int f_putc (
   5624          	TCHAR c,	/* A character to be output */
   5625          	FIL* fp		/* Pointer to the file object */
   5626          )
   5627          {
   5628          	putbuff pb;
   5629          	UINT nw;
   5630          
   5631          
   5632          	pb.fp = fp;			/* Initialize output buffer */
   5633          	pb.nchr = pb.idx = 0;
   5634          
   5635          	putc_bfd(&pb, c);	/* Put a character */
   5636          
   5637          	if (   pb.idx >= 0	/* Flush buffered characters to the file */
   5638          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5639          		&& (UINT)pb.idx == nw) return pb.nchr;
   5640          	return EOF;
   5641          }
   5642          
   5643          
   5644          
   5645          
   5646          /*-----------------------------------------------------------------------*/
   5647          /* Put a string to the file                                              */
   5648          /*-----------------------------------------------------------------------*/
   5649          
   5650          int f_puts (
   5651          	const TCHAR* str,	/* Pointer to the string to be output */
   5652          	FIL* fp				/* Pointer to the file object */
   5653          )
   5654          {
   5655          	putbuff pb;
   5656          	UINT nw;
   5657          
   5658          
   5659          	pb.fp = fp;				/* Initialize output buffer */
   5660          	pb.nchr = pb.idx = 0;
   5661          
   5662          	while (*str)			/* Put the string */
   5663          		putc_bfd(&pb, *str++);
   5664          
   5665          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   5666          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5667          		&& (UINT)pb.idx == nw) return pb.nchr;
   5668          	return EOF;
   5669          }
   5670          
   5671          
   5672          
   5673          
   5674          /*-----------------------------------------------------------------------*/
   5675          /* Put a formatted string to the file                                    */
   5676          /*-----------------------------------------------------------------------*/
   5677          
   5678          int f_printf (
   5679          	FIL* fp,			/* Pointer to the file object */
   5680          	const TCHAR* fmt,	/* Pointer to the format string */
   5681          	...					/* Optional arguments... */
   5682          )
   5683          {
   5684          	va_list arp;
   5685          	BYTE f, r;
   5686          	UINT nw, i, j, w;
   5687          	DWORD v;
   5688          	TCHAR c, d, str[32], *p;
   5689          	putbuff pb;
   5690          
   5691          
   5692          	pb.fp = fp;				/* Initialize output buffer */
   5693          	pb.nchr = pb.idx = 0;
   5694          
   5695          	va_start(arp, fmt);
   5696          
   5697          	for (;;) {
   5698          		c = *fmt++;
   5699          		if (c == 0) break;			/* End of string */
   5700          		if (c != '%') {				/* Non escape character */
   5701          			putc_bfd(&pb, c);
   5702          			continue;
   5703          		}
   5704          		w = f = 0;
   5705          		c = *fmt++;
   5706          		if (c == '0') {				/* Flag: '0' padding */
   5707          			f = 1; c = *fmt++;
   5708          		} else {
   5709          			if (c == '-') {			/* Flag: left justified */
   5710          				f = 2; c = *fmt++;
   5711          			}
   5712          		}
   5713          		while (IsDigit(c)) {		/* Precision */
   5714          			w = w * 10 + c - '0';
   5715          			c = *fmt++;
   5716          		}
   5717          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   5718          			f |= 4; c = *fmt++;
   5719          		}
   5720          		if (!c) break;
   5721          		d = c;
   5722          		if (IsLower(d)) d -= 0x20;
   5723          		switch (d) {				/* Type is... */
   5724          		case 'S' :					/* String */
   5725          			p = va_arg(arp, TCHAR*);
   5726          			for (j = 0; p[j]; j++) ;
   5727          			if (!(f & 2)) {
   5728          				while (j++ < w) putc_bfd(&pb, ' ');
   5729          			}
   5730          			while (*p) putc_bfd(&pb, *p++);
   5731          			while (j++ < w) putc_bfd(&pb, ' ');
   5732          			continue;
   5733          		case 'C' :					/* Character */
   5734          			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
   5735          		case 'B' :					/* Binary */
   5736          			r = 2; break;
   5737          		case 'O' :					/* Octal */
   5738          			r = 8; break;
   5739          		case 'D' :					/* Signed decimal */
   5740          		case 'U' :					/* Unsigned decimal */
   5741          			r = 10; break;
   5742          		case 'X' :					/* Hexdecimal */
   5743          			r = 16; break;
   5744          		default:					/* Unknown type (pass-through) */
   5745          			putc_bfd(&pb, c); continue;
   5746          		}
   5747          
   5748          		/* Get an argument and put it in numeral */
   5749          		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
   5750          		if (d == 'D' && (v & 0x80000000)) {
   5751          			v = 0 - v;
   5752          			f |= 8;
   5753          		}
   5754          		i = 0;
   5755          		do {
   5756          			d = (TCHAR)(v % r); v /= r;
   5757          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   5758          			str[i++] = d + '0';
   5759          		} while (v && i < sizeof str / sizeof str[0]);
   5760          		if (f & 8) str[i++] = '-';
   5761          		j = i; d = (f & 1) ? '0' : ' ';
   5762          		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
   5763          		do putc_bfd(&pb, str[--i]); while (i);
   5764          		while (j++ < w) putc_bfd(&pb, d);
   5765          	}
   5766          
   5767          	va_end(arp);
   5768          
   5769          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   5770          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5771          		&& (UINT)pb.idx == nw) return pb.nchr;
   5772          	return EOF;
   5773          }
   5774          
   5775          #endif /* !_FS_READONLY */
   5776          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   check_fs
        16   -> ld_dword
        16   -> ld_word
        16   -> move_window
       0   chk_chr
       0   clust2sect
      32   cmp_lfn
        32   -> ff_wtoupper
        32   -> ld_word
      24   create_chain
        24   -> get_fat
        24   -> put_fat
      40   create_name
        40   -> chk_chr
        40   -> ff_convert
        40   -> mem_set
      24   dir_alloc
        24   -> dir_next
        24   -> dir_sdi
        24   -> move_window
      32   dir_find
        32   -> cmp_lfn
        32   -> dir_next
        32   -> dir_sdi
        32   -> mem_cmp
        32   -> move_window
        32   -> sum_sfn
      24   dir_next
        24   -> clust2sect
        24   -> create_chain
        24   -> get_fat
        24   -> mem_set
        24   -> sync_window
      32   dir_read
        32   -> dir_next
        32   -> move_window
        32   -> pick_lfn
        32   -> sum_sfn
      48   dir_register
        48   -> dir_alloc
        48   -> dir_find
        48   -> dir_next
        48   -> dir_sdi
        48   -> gen_numname
        48   -> mem_cpy
        48   -> mem_set
        48   -> move_window
        48   -> put_lfn
        48   -> sum_sfn
      16   dir_remove
        16   -> dir_next
        16   -> dir_sdi
        16   -> move_window
      24   dir_sdi
        24   -> clust2sect
        24   -> get_fat
      16   f_close
        16   -> f_sync
        16   -> validate
      16   f_closedir
        16   -> validate
      56   f_getfree
        56   -> find_volume
        56   -> get_fat
        56   -> ld_dword
        56   -> ld_word
        56   -> move_window
      32   f_gets
        32   -> f_read
      32   f_lseek
        32   -> clust2sect
        32   -> create_chain
        32   -> disk_read
        32   -> disk_write
        32   -> get_fat
        32   -> validate
      96   f_mkdir
        96   -> clust2sect
        96   -> create_chain
        96   -> dir_register
        96   -> find_volume
        96   -> follow_path
        96   -> mem_cpy
        96   -> mem_set
        96   -> remove_chain
        96   -> st_clust
        96   -> st_dword
        96   -> sync_fs
        96   -> sync_window
      24   f_mount
        24   -> find_volume
        24   -> get_ldnumber
      88   f_open
        88   -> dir_register
        88   -> find_volume
        88   -> follow_path
        88   -> ld_clust
        88   -> ld_dword
        88   -> move_window
        88   -> remove_chain
        88   -> st_clust
        88   -> st_dword
      40   f_opendir
        40   -> dir_sdi
        40   -> find_volume
        40   -> follow_path
        40   -> ld_clust
     160   f_printf
       160   -> f_write
       160   -> putc_bfd
      88   f_putc
        88   -> f_write
        88   -> putc_bfd
      88   f_puts
        88   -> f_write
        88   -> putc_bfd
      40   f_read
        40   -> clust2sect
        40   -> disk_read
        40   -> disk_write
        40   -> get_fat
        40   -> mem_cpy
        40   -> validate
      32   f_readdir
        32   -> dir_next
        32   -> dir_read
        32   -> dir_sdi
        32   -> get_fileinfo
        32   -> validate
     152   f_rename
       152   -> clust2sect
       152   -> dir_register
       152   -> dir_remove
       152   -> find_volume
       152   -> follow_path
       152   -> get_ldnumber
       152   -> ld_clust
       152   -> mem_cpy
       152   -> move_window
       152   -> st_clust
       152   -> sync_fs
      72   f_stat
        72   -> find_volume
        72   -> follow_path
        72   -> get_fileinfo
      24   f_sync
        24   -> disk_write
        24   -> move_window
        24   -> st_clust
        24   -> st_dword
        24   -> st_word
        24   -> sync_fs
        24   -> validate
      16   f_truncate
        16   -> disk_write
        16   -> get_fat
        16   -> remove_chain
        16   -> validate
     120   f_unlink
       120   -> dir_read
       120   -> dir_remove
       120   -> dir_sdi
       120   -> find_volume
       120   -> follow_path
       120   -> ld_clust
       120   -> remove_chain
       120   -> sync_fs
      40   f_write
        40   -> clust2sect
        40   -> create_chain
        40   -> disk_read
        40   -> disk_write
        40   -> mem_cpy
        40   -> validate
      40   find_volume
        40   -> check_fs
        40   -> disk_initialize
        40   -> disk_status
        40   -> get_ldnumber
        40   -> ld_dword
        40   -> ld_word
        40   -> move_window
      24   follow_path
        24   -> create_name
        24   -> dir_find
        24   -> dir_sdi
        24   -> ld_clust
      24   gen_numname
        24   -> mem_cpy
      24   get_fat
        24   -> ld_dword
        24   -> ld_word
        24   -> move_window
      24   get_fileinfo
        24   -> ff_convert
        24   -> ld_dword
        24   -> ld_word
       4   get_ldnumber
      16   ld_clust
        16   -> ld_word
       0   ld_dword
       0   ld_word
       4   mem_cmp
       0   mem_cpy
       0   mem_set
      16   move_window
        16   -> disk_read
        16   -> sync_window
      24   pick_lfn
        24   -> ld_word
      24   put_fat
        24   -> ld_dword
        24   -> move_window
        24   -> st_dword
        24   -> st_word
      32   put_lfn
        32   -> st_word
      24   putc_bfd
        24   -> f_write
        24   -> putc_bfd
      24   remove_chain
        24   -> get_fat
        24   -> put_fat
      16   st_clust
        16   -> st_word
       0   st_dword
       0   st_word
       0   sum_sfn
      16   sync_fs
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set
        16   -> st_dword
        16   -> st_word
        16   -> sync_window
      24   sync_window
        24   -> disk_write
      16   validate
        16   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable6
       4  ??DataTable9
      12  ?_0
       8  ?_1
     128  ExCvt
       4  FatFs
       2  Fsid
     512  LfnBuf
      16  LfnOfs
      96  check_fs
      20  chk_chr
      26  clust2sect
     166  cmp_lfn
     212  create_chain
     602  create_name
     102  dir_alloc
     276  dir_find
     290  dir_next
     258  dir_read
     366  dir_register
     102  dir_remove
     166  dir_sdi
      42  f_close
      28  f_closedir
     262  f_getfree
      80  f_gets
     392  f_lseek
     396  f_mkdir
      92  f_mount
     396  f_open
     150  f_opendir
     612  f_printf
      66  f_putc
      76  f_puts
     458  f_read
     106  f_readdir
     304  f_rename
      86  f_stat
     158  f_sync
     212  f_truncate
     224  f_unlink
     564  f_write
     728  find_volume
     150  follow_path
     144  gen_numname
     214  get_fat
     278  get_fileinfo
      72  get_ldnumber
      38  ld_clust
      22  ld_dword
      12  ld_word
      30  mem_cmp
      20  mem_cpy
      12  mem_set
      62  move_window
     130  pick_lfn
     294  put_fat
     136  put_lfn
      78  putc_bfd
     140  remove_chain
      42  st_clust
      24  st_dword
      14  st_word
      32  sum_sfn
     148  sync_fs
      84  sync_window
      64  validate

 
    518 bytes in section .bss
    164 bytes in section .rodata
 10'414 bytes in section .text
 
 10'414 bytes of CODE  memory
    164 bytes of CONST memory
    518 bytes of DATA  memory

Errors: none
Warnings: none
